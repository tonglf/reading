# 第 10 章  点云

本章首先介绍 PCL 库的背景、相关的数据类型，以及 ROS 接口消息，然后展示一些关于如何使用 PCL 库处理数据以及如何通过 ROS 发送和接收数据的技术。

## 10.0 安装 PCL

### 安装

```bash
sudo apt update
sudo apt install libpcl-dev
sudo apt install pcl-tools
```

### 测试

```bash
virtual-machine:~$ pcl_v		#(按两下 Tab键)
pcl_vfh_estimation                   pcl_voxel_grid_occlusion_estimation
pcl_viewer                           pcl_vtk2obj
pcl_virtual_scanner                  pcl_vtk2pcd
pcl_vlp_viewer                       pcl_vtk2ply
pcl_voxel_grid 
```

若能够弹出以上信息，则说明 PCL 安装成功。

### 显示点云

```bash
pcl_viewer xxx.pcd
```

## 10.1 理解点云库

下面是点云中最重要的公共字段。

- header：这个字段是 pcl::PCLHeader 类型，指定了点云的获取时间。
- points：这个字段是 std::vector<PointT, ...>类型，它是存储所有点的容器。vector 定义中的 PointT 对应于类的模板参数，即点的类型。
- width：这个字段指定了点云组织成一种图像时的宽度，否则它包含的是云中点的数量。
- height：这个字段指定了点云组织成一种图像时的高度，否则它总是1。
- is_dense：这个字段指定了点云中是否有无效值(无穷大或NaN值)。
- sensor_origin\_：这个字段是 Eigen:Vector4f 类型，并且定义了传感器根据相对于原点的平移所得到的位姿。
- sensor_orientation_ ：这个字段是 Eigen::Quaternionf 类型，并且定义了传感器旋转所得到的位姿。



### 10.1.1 不同的点云类型

PCL 定义了许多不同类型的点，下面是一些最常用到的类型：

- pcl:PointXYZ：这是最简单也可能是最常用到的点类型;它只存储了 3D xyz 的信息。
- pcl:PointXYZl：这种类型非常类似于上面的那种，但它还包含了一个描述点亮度 (intensity) 的字段。当想要获取传感器返回的亮度高于一定级别的点时，它非常有用。还有与此相似的其他两种标准的点数据类型：一是pcl::InterestPoint，它有一个字段存储强度(strength)；二是 pcl::PointWithRange，它有一个字段用来存储距离(视点到采样点)，而不是亮度或强度。
- pcl::PointXYZRGBA：这种点类型存储 3D 信息，也存储颜色 ( RGB=Red, Green, Blue）和透明度 (A=Alpha)。
- pcl::PointXYZRGB：这种点类型与前面的点类型相似，但是它没有透明度字段。
- pcl::Normal：这是最常用的点类型，表示曲面上给定点处的法线以及测量的曲率。
- pcl::PointNormal：这种点类型跟前一个点类型一样，它包含了给定点所在曲面法线以及曲率信息，但是它也包含了点的 3D XYZ 坐标。这种点类型的变异类型是 PointXYZRGB-Normal 和 PointXYZINormal，顾名思义，它们包含了颜色(前者）和亮度(后者)。



### 10.1.2 PCL中的算法



### 10.1.3 ROS的PCL接口

通过 ROS 自带的基于消息的通信系统，ROS 的 PCL 接口提供了与 PCL 数据结构进行通信所需要的方法。为此，这里定义了不同的消息类型去处理点云和其他 PCL 算法中产生的数据。结合这些消息类型，也提供了一组将本地PCL 数据类型转换为消息的函数。

其中一些最重要的消息类型如下所示：

- std_msgs::Header：这不是真的消息类型，但它通常是每一个 ROS 消息的一部分。它包含消息发送时间、序列号和坐标系名称等信息。这个 PCL 类型等价于 pcl::Header type。
- **sensor_msgs::PointCloud2**：这也许是最重要的消息类型。这个消息用来传递 pcl::PointCloud 类型。然而，必须考虑的是，在未来支持 pcl::PCLPointCloud2 的 PCL 版本中这个消息类型将会弃用。
- pcl_msgs::PointIndices：这个消息类型存储了一个点云中点的索引，等价的 PCL 类型是 pcl:PointIndices。
- pcl_msgs::PolygonMesh：这个消息类型保存了描绘网格(即顶点和多边形)的信息，等价的 PCL 类型是pcl::PolygonMesh。
- pcl_msgs::Vertices：这个消息类型将一组顶点的索引保存在一个数组中，例如，用于描述一个多边形。等价的 PCL 类型是 pcl::Vertices。
- pcl_msgs::ModelCoefficients：这个消息类型存储了一个模型的不同系数，例如描述一个平面需要的 4 个参数。等价的 PCL 类型是 pcl::ModelCoefficients。

通过 ROS 的 PCL 功能包提供的转换函数可以将前面的消息转换为 PCL 类型或者从 PCL 类型转换为消息。所有这些函数都有一个相似签名 ( signature)，这意味着一旦我们知道如何转换一个类型，就知道如何转换所有的类型了。下面的函数是由 pcl_conversions 命名空间提供的:

```cpp
void fromPCL(const <PCL Type> &, <ROS Message type> &);
void moveFromPCL(<PCL Type> &, <ROS Message type> &);
void toPCL(const <ROS Message type> &, <PCL Type> &);
void moveToPCL(<ROS Message type> &, <PCL Type>&);
```

这里，PCL Type 必须用一个预先指定的 PCL 类型替代，ROS Message type 必须用消息类型替代。sensor_msgs::PointCloud2 指定了—组函数执行这些转换:

```cpp
void toROSMsg(const pcl::PointCloud<T>&, sensor_msgs::PointCloud2&);
void fromROSMsg(const sensor_msgs::PointCloud2&, pcl::PointCloud<T>&);
void moveFromRoSMsg(sensor_msgs::PointCloud2 &, pcl::Pointcloud<T>&);
```

你也许会好奇每个函数和它的 move 版本之间的区别。答案很简单，标准版本执行对数据的深复制，而 move 版本执行浅复制并注销源数据容器。这称为移动语义( move semantics) 。



## 10.2 我的第一个PCL程序

新建一个功能包，该功能包依赖如下：

```bash
catkin_create_pkg 包名 roscpp rospy std_msgs pcl_conversions pcl_ros pcl_msgs sensor_msgs
```

修改 CmakeLists.txt 文件：

```cmake
find_package(PCL REQUIRED)	#(添加)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
  ${PCL_INCLUDE_DIRS}		#(添加)
)
```

### 10.2.1 创建点云

在下面第一个示例中，读者将会学习如何创建仅由伪随机点组成的 PCL 点云。这个 PCL 点云最终会通过一个称为 /pcl_output 的主题定期发布出去。下面的示例展示了为将点云广播到订阅者，如何产生带有定制数据的点云以及如何将它们转换为相应的 ROS 消息类型。

**代码：**

```cpp
#include <ros/ros.h>
#include <pcl/point_cloud.h>
#include <pcl_conversions/pcl_conversions.h>
#include <sensor_msgs/PointCloud2.h>

int main (int argc, char *argv[])
{
    ros::init (argc, argv, "pcl_create");

    ros::NodeHandle nh;
    ros::Publisher pcl_pub = nh.advertise<sensor_msgs::PointCloud2> ("pcl_output", 1);
    pcl::PointCloud<pcl::PointXYZ> cloud;
    sensor_msgs::PointCloud2 output;

    // Fill in the cloud data
    cloud.width  = 100;
    cloud.height = 1;
    cloud.points.resize(cloud.width * cloud.height);

    for (size_t i = 0; i < cloud.points.size (); ++i)
    {
        cloud.points[i].x = 1024 * rand () / (RAND_MAX + 1.0f);
        cloud.points[i].y = 1024 * rand () / (RAND_MAX + 1.0f);
        cloud.points[i].z = 1024 * rand () / (RAND_MAX + 1.0f);
    }

    //Convert the cloud to ROS message
    pcl::toROSMsg(cloud, output);
    // 设置frame_id字段,为了能够在 RViz 可视化程序中可视化PointCloud2消息
    output.header.frame_id = "odom";


    ros::Rate loop_rate(1);
    while (ros::ok())
    {
        pcl_pub.publish(output);
        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}
```

**修改 CmakeLists.txt 文件：**

```cmake
add_executable(pcl_create src/pcl_create.cpp)

target_link_libraries(pcl_create 
	${catkin_LIBRARIES} 
	${PCL_LIBRARIES}		# (添加)
)
```

**启动节点**

```bash
roscore						# 启动 roscore

catkin_make					# 编译
source ./devel/setup.bash	# 更新配置文件
rosrun pkg pcl_create
```

**在 rviz 中显示**

```bash
rviz		# 开启 rviz
```

为能显示出点云，在打开 rviz 界面后，做如下修改：

1. 将上方 Fixed Frame 由 map 修改为 odom（这是自己设置的，output.header.frame_id = "odom";）
2. 点击 Add 添加 PointCloud2 类型，点击 PointCloud2 打开后，在 Topic 一栏中，选择 /pcl_output（话题，自己设置的）。

这样点云就在 rviz 中显示了。

### 10.2.2 加载和保存点云到硬盘中

**加载点云**

```cpp
#include "ros/ros.h"
#include "pcl/point_cloud.h"
#include "pcl_conversions/pcl_conversions.h"
#include "sensor_msgs/PointCloud2.h"
#include "pcl/io/pcd_io.h"

int main(int argc, char* argv[]) {
    ros::init(argc, argv, "pcl_read");
    ros::NodeHandle nh;
    ros::Publisher pcl_pub = nh.advertise<sensor_msgs::PointCloud2>("pcl_output", 1);

    sensor_msgs::PointCloud2 output;
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::io::loadPCDFile("/home/tong/文档/ROS-2022.4/FileSystem/src/ros_pcl/data/test_pcd.pcd", *cloud);	// 问题，设置相对路径不行

    pcl::toROSMsg(*cloud, output);
    output.header.frame_id = "odom";

    ros::Rate loop_rate(1);
    while (ros::ok())
    {
        pcl_pub.publish(output);
        ros::spinOnce();
        loop_rate.sleep();
    }
    
    return 0;
}
```

**保存点云**

```cpp
#include "ros/ros.h"
#include <pcl/point_cloud.h>
#include "pcl_conversions/pcl_conversions.h"
#include "sensor_msgs/PointCloud2.h"
#include <pcl/io/pcd_io.h>

void cloudCB(const sensor_msgs::PointCloud2::ConstPtr &input)
{
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::fromROSMsg(*input, *cloud);
    pcl::io::savePCDFileASCII("/home/tong/文档/ROS-2022.4/FileSystem/src/ros_pcl/data/write.pcd", *cloud);
}

int main(int argc,  char* argv[])
{
    ros::init(argc, argv, "pcl_write");

    ros::NodeHandle nh;
    ros::Subscriber bat_sub = nh.subscribe<sensor_msgs::PointCloud2>("pcl_output", 10, cloudCB);

    ros::spin();

    return 0;
}
```

**修改 CmakeLists.txt 文件：**

```cmake
add_executable(02_pcl_read src/02_pcl_read.cpp)
add_executable(03_pcl_write src/03_pcl_write.cpp)

target_link_libraries(02_pcl_read 
	${catkin_LIBRARIES} 
	${PCL_LIBRARIES}		# (添加)
)
target_link_libraries(03_pcl_write 
	${catkin_LIBRARIES} 
	${PCL_LIBRARIES}		# (添加)
)
```

**添加 launch 文件：**

```xml
<launch>
    <node pkg = "ros_pcl" type = "02_pcl_read" name = "read" />
    <node pkg = "ros_pcl" type = "03_pcl_write" name = "write" />
</launch>
```

**启动**

```bash
roslaunch ros_pcl startup.launch
```



### 10.2.3 可视化点云

点云可视化在 PCL 中有两个类，分别为 CloudViewer 和 Visualizer，本节以 CloudViewer 为例，Visualization 放到下一小节。

代码：

```cpp
#include <iostream>
#include "ros/ros.h"
#include <pcl/visualization/cloud_viewer.h>
#include <sensor_msgs/PointCloud2.h>
#include <pcl_conversions/pcl_conversions.h>

class cloudHandler {
public:
    cloudHandler(): viewer("Cloud Viewer")
    {
        pcl_sub = nh.subscribe("pcl_output", 10, &cloudHandler::cloudCB, this);
        viewer_timer = nh.createTimer(ros::Duration(0, 1), &cloudHandler::timerCB, this);	// 设置定时器，每 100ms 触发一次回调检查窗口是否关闭
    }

    void cloudCB(const sensor_msgs::PointCloud2::ConstPtr input)
    {
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
        pcl::fromROSMsg(*input, *cloud);
        viewer.showCloud(cloud);
    }

    void timerCB(const ros::TimerEvent&)
    {
        if (viewer.wasStopped())	// 窗口是否关闭，已经关闭则终止代码的执行
        {
            ros::shutdown();
        }
    }

private:
    ros::NodeHandle nh;
    ros::Subscriber pcl_sub;
    pcl::visualization::CloudViewer viewer;
    ros::Timer viewer_timer;
};

int main(int argc, char* argv[])
{
    ros::init(argc, argv, "pcl_visualize");

    cloudHandler handler;

    ros::spin();

    return 0;
}
```

与之前的 pcl_read 搭配使用：

修改CMakeLists.tx

launch 文件：

```xml
<launch>
    <!-- 04 visualize point cloud -->
    <node pkg = "ros_pcl" type = "02_pcl_read" name = "read" />
    <node pkg = "ros_pcl" type = "04_pcl_visualize" name = "cloudviewer" />
</launch>
```

运行。



### 10.2.4 滤波和缩减采样



### 10.2.5 配准与匹配



## 10.2.6 点云分区



## 10.3 分割



## 10.4 本章小结

本章探讨了 PCL 中各种不同的工具、算法和用来与 ROS 中的点云进行交互的接口，展现了如何将 PCL 库的基本功能与 ROS 集成。