### 1.9.6  function call 操作符( operator() )

很少有人注意到，函数调用操作 ( C++ 语法中的左右小括号 ）也可以被重载。

许多 STL 算法都提供了两个版本，一个用于一般状况（ 例如排序时以递增方式排列 )，一个用于特殊状况（ 例如排序时由使用者指定以何种特殊关系进行排列 )。像这种情况，需要用户指定某个条件或某个策略，而条件或策略的背后由一整组操作构成，便需要某种特殊的东西来代表这 “整组操作”。

代表 “一整组操作” 的，当然是函数。过去 C 语言时代，欲将函数当做参数传递，唯有通过函数指针（ pointer to function，或称 function pointer ）才能达成，例如:

```cpp
// file: 1qsort.cpp

// c++使用函数对象/仿函数实现一组动作
// c使用函数指针实现一组动作，但是无法存储状态在里面

#include <cstdlib>
#include <ctime>
#include <iostream>
using namespace std;

int fcmp(const void *elem1, const void *elem2);

int main() {
	int ia[10] = {32, 92, 67, 58, 10, 4, 25, 52, 59, 54};
	
	for (int i = 0; i < 10; i++)
		cout << ia[i] << " ";		// 32 92 67 58 10 4 25 52 59 54 

	// 快速排序
	qsort(ia, sizeof(ia) / sizeof(int), sizeof(int), fcmp);

	for (int i = 0; i < 10; i++) 
		cout << ia[i] << " ";		// 4 10 25 32 52 54 58 59 67 92 
	
}

int fcmp(const void* elem1, const void* elem2) {
	const int *i1 = (const int *)elem1;
	const int *i2 = (const int *)elem2;

	if (*i1 < *i2)
		return -1;
	else if (*i1 == *i2)
		return 0;
	else
		return 1;
}
```

**但是函数指针有缺点，最重要的是它无法持有自己的状态（所谓局部状态，local states），也无法达到组件技术中的可适配性（ adaptability)——也就是无法再将某些修饰条件加诸于其上而改变其状态。**

为此，STL 算法的特殊版本所接受的所谓 “条件” 或 “策略” 或 “一整组操作”，都以仿函数形式呈现。所谓仿函数（ functor）就是使用起来像函数一样的东西。如果你针对某个 class 进行 operator() 重载，它就成为一个仿函数。至于要成为一个可配接的仿函数，还需要做一些额外的努力（详见第8章)。

下面是一个将 operator() 重载的例子:

```cpp
// file: 1functor.cpp

#include <iostream>
using namespace std;

// 由于将 operator() 重载了，因此 plus 成了一个仿函数
template <class T>
struct Plus {
	T operator() (const T& x, const T& y) const {
		return x + y;
	}
};

template <class T>
struct Minus {
	// const 后置修饰为常函数
	T operator() (const T& x, const T& y) const {
		return x - y;
	}
};


int main() {
	// 生成仿函数对象
	Plus<int> plusobj;
	Minus<int> minusobj;

	// 以下使用仿函数，就像使用一般函数一样
	cout << plusobj(3, 5) << endl;		// 8
	cout << minusobj(3, 5) << endl;		// -2

	// 以下直接产生仿函数的临时对象（第一对小括号），并调用之（第二对小括号）
	cout << Plus<int>()(43, 50) << endl;	// 93
	cout << Minus<int>()(43, 50) << endl;	// -7
}
```

上述的 plus\<T> 和 minus\<T> 已经非常接近 STL 的实现了，唯一的差别在于它缺乏 “可配接能力”。关于 “可配接能力”，将在第 8 章详述。