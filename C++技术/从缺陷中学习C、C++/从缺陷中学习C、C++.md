# 从缺陷中学习C/C++

《从缺陷中学习C/C++》这本书收集并整理了102个实例，这些实例都来自于工程一线实践，虽然大多数看起来像是初学者犯的低级错误，但实质上有一定的代表性，有的错误根源是对C++机制的不理解或者编译过程中的副作用，或者是对C++标准库的实现依赖。通过阅读这些实例，你可以对C++有更细致的理解。

## 目录

第 1 章  [基础问题](file/1.基础问题.md)

​	1.1 运算符优先级引起的问题
​	1.2 不加括号的宏定义引起的错误
​	1.3 污染环境的宏定义
​	1.4 多语句宏定义使用错误
​	1.5 char转为int时高位符号扩展的问题
​	1.6 int转为char时的数据损失
​	1.7 非法的数组下标
​	1.8 有符号int与无符号int比较的后果
​	1.9 有符号的困惑
​	1.10 整除的精度问题
​	1.11 浮点数比较的精度问题
​	1.12 最小负整数取相反数溢出
​	1.13 临时变量溢出
​	1.14 size_t导致的死循环
​	1.15 误用short引起缓冲区溢出
​	1.16 区分continue和return
​	1.17 指针常量和常量指针的区别
​	1.18 字符数组和指针不总是等价的
​	1.19 结构体成员变量初始化的隐患
​	1.20 返回值非void的函数没有返回值
​	1.21 cin> >和getline混用导致的奇怪问题
​	1.22 小结



第 2 章  [编译问题](file/2.编译问题.md)

​	2.1 动态链接库加载错误版本
​	2.2 相同名称静态库的链接顺序
​	2.3 使用命名空间来区分不同cpp中的同名类
​	2.4 C++模板编译时依赖名称查找
​	2.5 违背ODR原则可能会带来的意想不到的问题
​	2.6 变量共用内存时使用O2优化编译
​	2.7 小结

第 3 章  [库函数问题](file/3.库函数问题.md)

​	3.1 sprintf函数引起的缓冲区溢出
​	3.2 snprintf函数format参数的问题
​	3.3 错误使用snprintf函数返回值
​	3.4 字符串复制不完整
​	3.5 string类的c_str方法使用不当
​	3.6 string类的“[]”操作符使用不正确
​	3.7 不正确的字符串比较
​	3.8 strncpy函数没有复制结束符
​	3.9 调用memcpy函数前未初始化缓冲区
​	3.10 误用sizeof操作符取字符串长度
​	3.11 string类find函数返回值判定
​	3.12 stringstream的清空
​	3.13 调用strptime函数前需初始化tm
​	3.14 使用feof函数的陷阱
​	3.15 for循环中调用vector容器insert函数
​	3.16 multiset容器erase函数的误用
​	3.17 慎用容器类erase函数的返回值
​	3.18 for循环中调用vector容器erase函数
​	3.19 getopt函数参数问题
​	3.20 不用errno判断系统调用是否成功
​	3.21 strcat函数造成的段错误
​	3.22 危险的strdup函数
​	3.23 小结

第 4 章 [文件处理](file/4.文件处理.md)

​	4.1 程序异常退出时未关闭已打开文件
​	4.2 目录打开后未关闭
​	4.3 写文件没有调用fflush
​	4.4 读文件fread的返回值不能忽略
​	4.5 getline()使用不当导致的死循环
​	4.6 未重置流状态导致读文件错误
​	4.7 小结

第 5 章  [类和对象](file/5.类和对象.md)

​	5.1 对象的浅复制
​	5.2 构造函数中的操作符重载
​	5.3 拷贝构造函数不能模板化
​	5.4 析构函数未捕获异常引发coredump
​	5.5 构造函数中抛出异常引起内存泄露
​	5.6 多态性未生效
​	5.7 基类成员函数被隐藏
​	5.8 匿名对象引起的内存泄露
​	5.9 基类非虚析构函数引发内存泄露
​	5.10 删除void*指针引发内存泄露
​	5.11 STL容器不会自动释放指针指向的对象
​	5.12 静态成员类内初始化
​	5.13 union作为类的成员时需要构造函数
​	5.14 成员函数尾部缺失const标注
​	5.15 使用memset初始化class
​	5.16 dynamic_cast转换失败返回NULL
​	5.17 小结

第 6 章  [内存使用](file/6.内存使用.md)

6.1数组越界
6.2数组定义和值初始化形式混淆
6.3数组传参时的sizeof
6.4 临时对象的生存期