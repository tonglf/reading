## 第 2 章  编译问题

### 2.1 动态链接库加载错误版本

**编程建议**
动态链使用前先export LD_LIBRARY_PATH是一个良好的编程习惯。



### 2.2 相同名称静态库的链接顺序

**编程建议**
良好的 lib 命名规范可以避免同类问题的发生。



### 2.3 使用命名空间来区分不同cpp中的同名类

**编程建议**
注意命名空间的使用，不能滥用，防止冲突。



### 2.4 C++模板编译时依赖名称查找

**代码示例**

```cpp
template <class Type>
class ClassA
{
protected:
    int num;
};

template <class Type>
class ClassB : public ClassA<Type>
{
public:
    void init() { num = 0; }
};

int main()
{
    ClassB<int> b;
    b.init();

    return 0;
}
```

**现象&后果**

上面这段代码在早年版本的GCC下编译能通过，但使用新的GCC版本编译时出现错误：“num' was not declared in this scope”

**Bug分析**

因为在编译时，C++ 会分两个阶段的名字查找来解析模板的语法，第一阶段会扫描所有非依赖名称，第二阶段（实例化模板）会扫描所有的依赖名称。所谓依赖名称，是指那些在编译时被认为是依赖于模板参数，只有在模板实例化时才能消歧的名称；反之则是非依赖名称。在上面的代码中, num 变量被编译器看作是非依赖名称，所以要在第一阶段的解析过程中识别 num 变量，但由于目前编译器还没有实现在模板基类中对非依赖名称的查找，所以在类ClassB\<Type>作用域没有找到num变量，故报出上面的错误。

早期的 GCC 并没有真正实现两阶段名字查找机制，在对模板类的语法解析时，将所有的名字查找都留到了实例化的时候进行，所以上面的代码可以通过编译。

**正确代码**

在变量 num 之前加上 this->，使变量 num 成为依赖名称，这样对变量 num 的查找会在第二阶段进行，程序会正常编译通过:

```cpp
template <class Type>
class ClassA
{
protected:
    int num;
};

template <class Type>
class ClassB : public ClassA<Type>
{
public:
    void init() { this->num = 0; }
};

int main()
{
    ClassB<int> b;
    b.init();

    return 0;
}
```



### 2.5 违背ODR原则可能会带来的意想不到的问题

**编程建议**
单定义规则是构建一个良好 C++ 工程的基础，尤其当程序文件较多，声明与实现相分离，需要 include 头文件的情况下，更容易违反。多次引用 .h 文件造成变量重复定义是比较常犯的错误，编译器也能事先发现。像上述类型较为隐蔽，也不易追查，须更加注意，养成良好的编码规范。



### 2.6 变量共用内存时使用O2优化编译

**编程建议**
优化编译可以在一定程度上提升性能，但它有可能会带来一些不可预料的问题，而且经过优化的程序也不易调试，因此，如果对性能的要求不高，在编译时可通过编译选项 “-O0” 去掉编译器的优化。



### 2.7 小结

编译链接是程序代码变为机器可执行代码的第一步，也是很重要的一步，了解编译器链接器的过程和原理，能有效避免后续执行中出现的一些与程序逻辑无关的问题。这章主要列举了编译链接过程中容易出现的一些问题，包括动态和静态链接库的链接加载顺序、编译参数等，相信读者从这几个案例中可以有所借鉴。