## 第 4 章 文件处理

### 4.1 程序异常退出时未关闭已打开文件

**代码示例**

```cpp
const char *pFile1 = "app.conf";
const char *pFile2 = "app.data";
FILE *fp1 = fopen(pFile1,"r");
if ( !fp1 ) {
    fprintf(stderr,"Can not open %s forread.\n", pFile1);
    return -1;
}
FILE *fp2 = fopen(pFile2, "r");
if ( !fp2 ){
    fprintf(stderr,"Can not open %s forread.\n", pFile2);
    return -1;
}
fclose(fp1);
fclose(fp2);
```

**现象&后果**

程序编译运行正常，但当用静态代码检查工具 cppcheck 检查时，提示有资源泄露发生。

**Bug分析**

程序中打开了两个文件，对于每个文件如果打开失败则程序退出。但当第二个文件 pFile2(指针 fp2 所指)打开失败时，在退出前并未将已经打开的文件 pFile1 (即指针 fp1 所指)关闭，从而造成资源泄露 (resourceleak)，为程序留下隐患。程序员一个好的编程习惯是，在程序中的所有出口，检查之前已经申请的资源，释放该释放的，防止有内存或资源泄露发生。这里的解决办法就是在 return 之前关闭文件 pFile1。

**正确代码**

```cpp
if ( !fp2 ){
    fprintf(stderr,"Can not open %s forread.\n", pFile2);
	fclose(fp1);
    return -1;
}
```

**编程建议**
当程序发生异常做退出处理时，忘记关闭已经打开的文件是一种很常见的 Bug。对于这样的 Bug，编译器往往能顺利编译通过，程序也能照常运行，但这确实是一个隐患。频繁地打开文件但不关闭可能会导致该进程或该用户打开的文件数超过最大限制而导致程序崩溃。这类 Bug 引起的程序崩溃或异常，一般不容易定位问题根源。类似的情形还有，socket 文件描述符未关闭，用 new 或 malloc 申请的内存未释放等。这类资源泄露问题一般可以通过静态代码检查工具，如 cppcheck 检查出来。



### 4.2 目录打开后未关闭

**代码示例**

```cpp
int main(int argc, char *argv[])
{
    char isFile = 0x8;
    DIR* dir = opendir("tmpdir");
    struct dirent* ptr = NULL;
    while ((ptr = readdir(dir)) != NULL)
    {
        if (ptr->d_type = = isFile)
            cout << ptr->d_name << endl;
    }
}
```

**现象&后果**

程序编译运行正常，但当用静态代码检查工具 cppcheck 检查时提示有资源泄露发生。

**Bug分析**

上面代码的目的是打开一个目录，遍历该目录下的所有文件，并输出每个文件的文件名。这里的问题其实与前面退出时文件未关闭的例子类似。代码中在用 opendir 打开目录后并未将其关闭。操作目录和操作文件是类似的，操作完需要关闭。

**正确代码**

```cpp
// 在main函数退出前关闭目录
closedir(dir);
```

**编程建议**
文件打开需关闭是大多数程序员都知道的常识，但打开目录后也需关闭却可能被忽视。



### 4.3 写文件没有调用fflush

**代码示例**

```cpp
int main()
{
    FILE*fp;
    fp = fopen("info.log " ,"w");
    fprintf(fp, "%s", "hello world");
    // do something here and write logf
    close(fp);
    return 0;
}
```

**现象&后果**

当程序中途出现了运行时错误并异常退出时，发现应该写入的日志并没有写入日志文件中。

**Bug分析**

程序本来想记录日志，在操作后记录一些信息以便调试。然而，当程序中途出现运行时错误，日志文件中的内容可能不完整。

当输出终端是文件时，每次调用 fprintf 时并没有真正把数据写入文件中，而是先写到缓冲区，只有当缓冲区满的时候，才会真正将缓冲区的内容写入文件中，并清空缓冲区。这和输出到屏幕不同，当输出到屏幕时，除了缓冲区满外，遇到 ‘\n’ 也会自动清空缓冲区，另外，读入内容也会清空缓冲区。当写入文件时，如果写入的内容比较重要，往往需要显式调用 fflush() 来强制将缓冲区写入文件。

**正确代码**

在每个 fprintf 语句，如果输出的日志相对比较重要，则在其后加一行 fflush(fp)。

**编程建议**
显式调用 fflush 来清空输出缓冲区是一个好习惯。这有助于日志文件的形成，以便于调试。



### 4.4 读文件fread的返回值不能忽略

**代码示例**

```cpp
{
    FILE *fp = fopen("data", "r");
    char* buffer = new char[size + 1];
    buffer[size] = '\0';
    int count = fread(&buffer[0], 1, size, fp);
    assert(count == size);
}
```

**现象&后果**

assert 断言被触发。

**Bug分析**

库函数 fread 返回已经成功读取的元素 items 的数量，代码中没有对返回值进行判断和处理，因为在 fread 执行的过程中有可能被信号中断，导致读取的元素的个数与预期的不一致，因此，在 fread 之后需要对返回值做判断，判断 count 是否等于 size 来判定读取的完整性。

**正确代码**

```cpp
char* buffer = new char[size + 1];
buffer[size] = '\0';
for (int i = 0; i < size;)
{
    int count = fread(&buffer[i], 1, size - i,fp);
    i += count;
}
```

**编程建议**
fread 在执行的过程中可能被信号中断，导致读取的内容不完整，需要在程序中判断和处理。对待 fwrite 也是同样的道理。



### 4.5 getline()使用不当导致的死循环

**代码示例**

```cpp
int main()
{
    ifstream infile;
    infile.open("example.txt" , ios:binary);
    char buffer[10];
    while(!infile.eof())) {
        infile.getline(buffer，sizeof(buffer),'\n');
        cout << buffer << endl;
    }
    return O;
}

/*
example.txt文件内容:
1234567890
abcdefghij
*/
```

**现象&后果**

程序执行时陷入死循环。

**Bug分析**

getline常用的函数定义有两类。

1. 全局函数 std:getline( istream& is, string& s, char delimiter = '/n')，从 is 中读取文件流到 s 中,delimiter 为读取分隔符，其中 s 必须为 string 类型。
2. 成员函数 std::istream::getline(char_type*_Str, streamsize _Count, char_type _Delim)，调用方式为: infile.getline(p ,count, 'n')，从 infile 中读取 count 个字符到 p 中, ‘n’ 为分隔符。

上段代码中用的是第二种方式，这里主要讲 getline 函数作为成员函数的运行逻辑。

1. 判断输入流状态，如果为 ios_base::failbit，则返回空字符串。
2. 判断读入字符，如果为文件尾，则设置文件流状态为 ios_base::eofbit，结束getline读取。
3. 判断读入字符，如果为\_Delim, \_Delim默认为 ‘\n’，则不把 \_Delim 放入缓冲区，结束本次读取，下次读取从 \_Delim 后下一个字符开始。
4. 判断读入字符个数，如果为 _Count，则结束本次读取，并把输入流状态设置为 ios_base::failbit。

在上段代码中，在读取文件第一行时，由于读取长度为 10 且不为 ‘\n’，就把文件流状态置为 ios_base::failbit ，后续在执行到 getline 时由于流状态已经为 ios_base::failbit，因此，getline 返回空字符串，不会读取后面的文件内容，导致文件一直处理不到文件尾，程序陷入死循环。

为了解决这个问题，最好在每次读取后，重置一下文件流的状态。

**正确代码**

```cpp
int main()
{
    ifstream infile;
    infile.open("example.txt" , ios:binary);
    char buffer[10];
    while(!infile.eof())) {
        infile.getline(buffer，sizeof(buffer),'\n');
        cout << buffer << endl;
        if(infile.gcount) == (sizeof(buffer) - 1))
            infile.clear();
    }
    return O;
}
```



### 4.6 未重置流状态导致读文件错误

**代码示例**

```cpp
int main()
{
    ifstream infile;
    infile.open(" example.txt",ios::binary);
    char buffer[255];
    int line = O;
    while(infile.getline(buffer, 255)){
        line++;
    }
    cout << "total line:" << line << endl;
    infile.seekg(0, ios:beg);
    while(infile.getline(buffer, 255)){
        cout << buffer << endl;
    }
    infile.close();
    return 0;
}
```

**现象&后果**

当第二次使用getline时没有读取到文件内容。

**Bug分析**

在上段代码中，第一次遍历文件计算行数后，就读取到了文件末尾，此时文件流状态为：ios::eofbit ，虽然后面重新设置了文件的读位置，但是文件流状态没有变化，故再次读文件时，文件流状态依然为 ios::eofbit ，该状态表示文件流已经达到文件结束符，因此，系统认为文件已经读完，不会重新读取文件。解决方法是在第二次遍历文件时，重置文件流状态。

**正确代码**

```cpp
int main()
{
    ifstream infile;
    infile.open(" example.txt",ios::binary);
    char buffer[255];
    int line = O;
    while(infile.getline(buffer, 255)){
        line++;
    }
    cout << "total line:" << line << endl;
    infile.clear();
    infile.seekg(0, ios:beg);
    while(infile.getline(buffer, 255)){
        cout << buffer << endl;
    }
    infile.close();
    return 0;
}
```



### 4.7 小结

C/C++ 所提供的对文件处理的接口并不复杂，初学者亦很容易上手使用，但实际使用时某些问题常常出现，如未关闭文件/目录句柄。由于大部分情况下不会出现程序错误，常被人忘记。fopen 总有 fclose 与之对应，这是一个规范，养成一个良好的编程习惯是避免 Bug 发生的最有效的方式。多阅读文档，增强对函数接口的深入理解是避免出现上述问题的根本。