## 第 8 章  性能问题

### 8.1 strlen用作循环条件影响性能

**代码示例**

```cpp
int main() {
    const char p[] = "1234567890ABCDEFGHIJ";
    for(int i = 0; i < strlen(p); i++) {
        printf(" %c\n",p[i]);
    }
}
```

**现象&后果**

这段程序的时间复杂度是O(n^2)，当字符串p较长时，CPU资源浪费非常严重。

**Bug分析**

在 for( i=0; i<strlen(p); i++) 循环中，每次循环的时候都要计算一次 strlen(p)。显然，如果字符串很长，如包含 10万个字符，那就要循环 10 万次，计算 10 万次 strlen。而 strlen 的一般实现是需要较高代价的，它需要遍历每个字符，即需要遍历 10 万个字符。这样整段代码的复杂度就是 10 万乘以 10 万，显然这样的程序效率是非常低的。因此，合理地实现是使用一个临时变量存储 strlen(p) 的值，将该变量用在循环判定条件中，这样就只需要计算一次 strlen(p)，避免了在循环中重复计算。这样上面代码的时间复杂度就可以优化到 O(n)。

**正确代码**

```cpp
int main() {
    const char p[] = "1234567890ABCDEFGHIJ";
    int len = strlen(p);
    for(int i = 0; i < len; i++) {
        printf(" %c\n",p[i]);
    }
}
```



### 8.2 STL容器list使用时忌频繁调用size()

**代码示例**

```cpp
int main() {
    list<int> lst;
    for(int i = 0; i < 10000; i++)
        lst.push_back(i);
    for(int i = 0; i < lst.size(); i++) {
        // do something
    }
}
```

**现象&后果**

STL 中 list 容器的 size() 方法的时间复杂度在 STL 标准中并没有明确要求，依赖于具体实现，有的是 O(1)，也有的是 O(n)。上面代码中每次循环都要做 i < lst.size() 的判断，如果 size() 的复杂度为 O(n)，则这段代码的时间复杂度变为 O(n^2)，这可能对性能造成极大的影响，当 list 中元素非常多的情况下尤其明显。

**Bug分析**

在 Linux 系统上(如 Red Hat 3.4.6, Rea Hat4.1.2)，GCC list 的 size() 的一般实现 (如GCcversion 3.4.6, GCC version 4.1.2)为:

```cpp
size_type size() const {
	return std:distance(begin(), end());
}
```

从上可以看到，是用 distance(begin(), end()) 来计算的。std::distance 的实现中，按照 iterator 类型的不同，实现的方式也不同。STL list 的 iterator ，是属于双向 iterator , 而非随机 iterator ,因此，在 std::distance() 中使用了—个循环来计算值。也就是说在 GCC 的 STL 中，每次调用 list::size() 函数，它都会从头到尾遍历一遍。因此size() 的时间复杂度是 O(n)。代码的整体复杂度变为 O(n^2)。

降低复杂度的一个办法就是使用一个临时变量存储size()的值，将该变量用在循环判定条件中，这样只计算一次size()，避免了在循环中重复计算。

**正确代码**

```cpp
int len = lst.size();
for(int i = 0; i < len; i++) {
    // do something
}
```

**编程建议**
STL 中 list 的 size() 方法的时间复杂度与具体实现有关，依赖于具体操作系统和版本。在多个 Redhat Linux系统下测试的多个版本中，大多数情况时间复杂度为 O(n)。所以在使用 list 的 size() 方法时，尤其当程序性能比较重要时，应该引起注意，循环越多对效率影响越大。此外与此类似的另外一种用法也要注意:

```cpp
list<int> lst;
while(lst.size() > 0) {}
```

这里可以改为使用 while(!lst.empty())，因为 empty() 的复杂度只是 O(1)，效率更好一些。



### 8.3 误用clear回收vector内存

**代码示例**

```cpp
int main() {
    vector<int> vec;
    for(int i = 0; i < 1000; i ++) {
        vec.push_back(i);
    }
    cout << "capacity = " << vec.capacity() << " size = " << vec.size() << endl;
    vec.clear();
    cout << "capacity = " << vec.capacity() << " size="<< vec.size() << endl;
    //do service processing
}
```

**现象&后果**

程序中声明了一个存储 1000 个整型元素的 vector，在使用完后用 clear 清除所有元素，发现元素数变为 0 以后程序占用的内存并没有减少。

**Bug分析**

在分析问题前可以先看一下 vector 在clear() 前后的元素个数和占用内存大小 ( vector B 的元素个数可以用vector.size()方法得到，vector 占用的内存可以用 vector.capacity() 方法得到 )∶

clear 前: capacity=1024 size=1000;

clear 后: capacity=1024 size=0。

可以看到 clear 后虽然 vec 的元素个数从1000 变为 0 了，但所占的内存空间大小依然为 clear 前的1024。这是因为 vector 的 clear() 方法做的事情是把 vector 内的元素全部删除掉，并调用元素所存储对象的析构函数释放对象，但这并不会改变 vector 本身所占用内存的大小。程序运行过程中 vector占用的内存如果增长上去，是无法通过 clear 方法释放掉的，vector占用内存只会越来越多。

解决这个问题的一个方法是，通过 swap() 方法完全释放 vector占用的内存。swap 后，vector 的 capacity 和 size都变为 0:
swap 前: capacity=1024 size=1000;
swap 后: capacity=0 size=0。

**正确代码**

使用 vector 的 swap() 方法释放内存实际是用了一个小技巧，swap() 方法功能是交换对象，即将当前对象内容与传进的同类型 vector 对象交换。这里就是通过将当前 vec 对象和一个空临时 vector 对象交换，交换之后，vec 对象的空间变为 0，临时对象占用的内存空间变为 vec 之前占用的内存空间。临时对象的作用域就是该语句，随着生命周期结束，该对象在被析构的时候会释放内存。这样就达到了释放 vec 占用内存空间的目的。

```cpp
// 释放全部
vector<int> ().swap(vec);

// 释放不用内存
vector<int> (vec).swap(vec);

// 另外的方法
vec.shrink_to_fit();
```

**编程建议**
假定一个服务程序使用 vector 存储所有在线用户数据，在高峰时段用户量达到1亿，vector 占用了10GB的内存，系统处于极高负载状态。随后用户量不断减少直到低谷 100 个，这时 vector占用的内存依然是10GB。调用clear方法只会减少 vector 中存储的用户数，但不会减少所占用内存。这种场景下就可以使用上面描述的方法降低程序所用内存，减轻系统负载。



### 8.4 calloc在glibc高版本下性能劣于低版本下

**代码示例**

```cpp
const int MAX_SIZE = 1024 * 1024;
int *array= (int*)calloc(MAX_SIZE，sizeof(int));
```

**现象&后果**

这段代码是用 calloc 申请 1MB个 int 型变量空间，因每个 int 占用4个字节，所以实际共申请 4MB 内存。这行malloc 代码在程序中被频繁执行。性能测试时，发现 calloc 申请内存语句在 Redhat Release 5 环境下运行速度比Release 4 慢上一倍，导致系统性能低于预期。

**Bug分析**



**正确代码**

因为程序需求中无需刻意对申请的内存清零，因此，改为使用malloc方法:

```cpp
int *array= (int*)malloc(MAX_SIZE * sizeof(int));
```



### 8.5 小结

从上面几个例子可以看到，要想让程序在时间、空间上有较好的性能，需要对常用到的库(如STL库)、函数、方法的内部实现有较深刻的了解（如时间、空间复杂度)。另一方面，对于频繁调用的代码，尽量做到简洁高效，循环中的性能浪费会对程序性能造成显著的影响。希望读者从这几个例子中有所收获。

