## 第 6 章  内存使用

### 6.1 数组越界

**代码示例**

```cpp
#define ARRAY_SIZE 1024

char strArray[ARRAY_SIZE];

strArray[ARRAY_SIZE] = '10;
```

**现象&后果**

数组访问越界，程序运行崩溃。

**Bug分析**

C或C++中，数组的下标地址范围是从[0 ~ (size-1)]，下标 size 已经超出了数组范围。

**正确代码**

```cpp
#define ARRAY_SIZE 1024

char strArray[ARRAY_SIZE];

strArray[ARRAY_SIZE - 1] = '10;
```



### 6.2 数组定义和值初始化形式混淆

**代码示例**

```cpp
int *ip = new int(12);

for (int i = 0; i < 12; i++) {
    ip[i] = i;
}

delete[] ip;
```

**现象&后果**

产生运行时错误，提示如下的错误信息：glibc detected *** free(): invalid next size(fast)

**Bug分析**

int *ip=new int(12) 表示 new 了一个整型变量，值是 12。ip 指向这个变量。

new 返回的指针 ip 是 int 类型，不是一个数组指针，赋值的时候，采用数组的方式，造成越界访问内存，并且在结束的时候用 delete[] 删除指针数组，造成程序崩溃。

解决方法是：把小括号改写成中括号。

**正确代码**

```cpp
int *ip = new int[12];

for (int i = 0; i < 12; i++) {
    ip[i] = i;
}

delete[] ip;
```



### 6.3 数组传参时的sizeof

**代码示例**

```cpp
void copy(int a[], int b[]) {
	memcpy(b, a, sizeof(a));
}
```

**现象&后果**

copy 函数执行后，内存中的内容与设想不符，目标数组 b 中的内容不完整，没有把源数组 a 中的内容全部复制过来。

**Bug分析**

memcpy 函数的原型是 void \*memcpy(void*dest, const void *src, size_t n);，它的功能是从源 src 所指的内存地址的起始位置开始复制 n 个字节到目标 dest 所指的内存地址的起始位置中。上述程序中，copy 函数的两个形参是数组 a 和数组 b，函数体中调用了 memcpy 函数，并且为 memcpy 函数的第三个参数赋值 sizeof(a)。程序的本意是期望 sizeof(a) 返回数组 a 所占的字节数，通过 memcpy 函数，把源数组 a 中的内容全部复制到目标数组 b中。但是数组 int a[] 作为 copy 函数的形参，在 copy 函数体内将退化成指针，所以，sizeof(a) 返回的是指针的字节数，而不是数组 a 的字节数。因此，数组 b 中只是部分复制了数组a中的内容。解决办法是：在 copy 函数中增加一个参数，作为数组复制的字节数。

**正确代码**

```cpp
void copy(int a[], int b[], int len) {
	memcpy(a, b, sizeof(int) * len);
}

void del(int a[], int len){
	memset(a, 0, sizeof(int) * len);
}
// 或者用数组的引用方式传参:
void copy(int a[], int (&b)[]){
	memcpy(a, b, sizeof(b));
}
```

**编程建议**
数组传递参数时，连同数组长度一起传入是一个好方法。或者用 std::vector 代替数组可以避免不必要的麻烦。使用数组的引用，作为函数的参数，也可以解决上面的问题。



### 6.4 临时对象的生存期

**代码示例**

```cpp
class MyString {
public:
    MyString() {
        s_= (char *)malloc(strlen(str) + 1);
        strcpy(s_, str);
    }
    ~MyString() {
        printf("destory\n");
    }

    friend MyString operator+(constMyString &lstr, const MyString &rstr) {
        size_t llen = strlen(lstr);
        size_t rlen = strlen(rstr);
        char buf[llen + rlen + 1];
        strcpy(buf, Istr);
        strcat(buf， rstr);
        return MyString(buf);
    }
    operator const char *() const { //当string转换char*时调用
        return _s;
    }
private:
    char *_s;
};

int main()
{
    MyString s1("hello"), s2("world!");
    const char *p = s1 + s2;
    printf(" %s\n",p);
    return 0;
}
```

**现象&后果**

程序运行时通常是正常的，但有时会出错，特别是在多线程时，会出现奇特的错误:例如，指针p指向的内容不是期望的内容。

**Bug分析**

错误出在 main 函数中的 const char *p = s1+s2 代码行处。程序会首先生成一个临时对象，用来存储 s1+s2 的值，然后再把临时对象的值赋给 p，随后该临时对象析构。所以，指针 p 指向了一块非法内存。因为临时对象已经被析构，所以这块非法内存被系统识别为“未使用”的状态，可以被再分配使用。如果在程序中没有其他操作读写这块内存时，其内容还没有被改变，所以，可能输出符合程序预期的正确结果。但是，没有任何方法阻止那块内容的改变。所以，如果有其他操作对这块内存单元进行写操作后，可能输出的是随机值。

**正确代码**

```cpp
int main()
{
	MyString s1("hello "), s2("world !");
	String temp = t1 + t2;
	const char *p = temp;
	printf(" %s\n", p);
	return 0;
}
```



### 6.5 变量的作用域

**代码示例**

```cpp
char *str = NULL;
if(!str) {
    char * str = (char*) malloc (100);
    if(!str) {
        return -1;
    }
    str[0] = 'a';
}
printf(" %c\n" , str[0]);
```

**现象&后果**

程序执行时出现 coredump。

**Bug分析**

注意变量作用域。

**正确代码**

```cpp
char *str = NULL;
if(!str) {
    str = (char*) malloc (100);
    if(!str) {
        return -1;
    }
    str[0] = 'a';
}
printf(" %c\n" , str[0]);
```



### 6.6 指针变量的传值和传址

**代码示例**

```cpp
int func(int* pRes) {
	if (pRes == NULL)
		pRes = new int(12); // 分配新的内存空间给指针 pRes,并赋值
	return 0;
}

int main() {
	int *plnt = NULL;
    int val = func(plnt);
    printf("%d\n", *pInt);
    return 0;
}
```

**现象&后果**

函数返回后，指针pRes所指内容不是12。

**Bug分析**

上述代码中 func 函数的形参是指针类型 int \*pRes，在函数体中 new 了一块内存并赋值 12，将内存地址赋值给指针 pRes。在 main 函数中，定义了指针 plnt，调用 func 函数，把 pInt 作为参数传入 func 函数中。程序的本意是在 func 函数退出后，指针 plnt 所指的内容 *pInt 为 12，但实际结果却不是。其原因是在 func 函数调用过程中，形参和实参的传递使用了值传递方式，这种情况下，形参变量在函数体内发生了变化，在函数结束之后，形参变量随之释放，不能把变化的结果返回给实参。要改变实参的值，必须使用指针传递或者引用传递。在本程序中，func 函数的形参是整形指针类型 int * pRes，要在函数体内改变 pRes 的值，并把这个变化返回到 main 函数中，必须传递 pRes 的指针。因为 pRes 本身就是指针，所以应该传递指针的指针，或者指针的引用。

**正确代码**

```cpp
int func(int* &pRes);
```



### 6.7 指针赋值和指针赋址的混淆

**代码示例**

```cpp
void function_b(int* num)
{
    int b = 20;
    int* buf =&b;
    if(*num < 0)
        num = num;
    else
        num = buf;
}

int main()
{
    int a = 10;
    int* num = &a;
    function_b(num);
    printf(" %d", *num);
    return 0;
}
```

**现象&后果**

num指针指向的内容没有发生变化。

**Bug分析**

程序的本意是定义并初始化指针 num，然后通过函数 function_b，改变指针所指的值，即 \*num。但是实际上没有改变，问题出在 function_b 中，赋值的用法不正确。应该使用取内容运算符为指针所指的内容赋值，而不是直接为指针赋值。\ *num=*buf 的含义是把指针 buf 所指的 value 赋值给指针 num 所指的 value，而 num=buf 的含义是把指针 buf 的地址赋给指针 num。

**正确代码**

```cpp
// 方法一
void function_b(int* &num)
    
// 方法二    
void function_b(int* num)
{
    int b = 20;
    int* buf =&b;
    if(*num < 0)
        *num = *num;
    else
        *num = *buf;
}
```

编程建议
函数中传递指针或引用参数，要注意修改是指针本身还是指针的内容，若不希望改变指针本身，建议加 const 声明，如: function_b(int* const num)。



### 6.8 指针释放后再次使用

**代码示例**

```cpp
class MyClass {
private:
    int m_val;
public:
    MyClass(int value) {
        m_val = value;
        printf( " new class A\n");
    }
    void getValue() {
        printf(" %d\n",m_val);
    }
};

void function_a() {
	MyClass *A = new MyClass (1);
	function_b(A);
	function_c(A);
}

void function_b(MyClass *& A) {
	MyClass *B = new MyClass(2);
    A->getValue();
	B->getValue();
    delete A;
    A= NULL;
    delete B;
    B = NULL;
}

void function_c(MyClass *&A) {
    A->getValue();
}

int main()				// 这个代码在 vscode 上运行正常
{
	function_a();
	return 0;
}
```

**现象&后果**

程序运行时出现coredump。

**Bug分析**

上述代码中，在函数 function_a 中实例化了 MyClass 对象指针 A，然后调用函数 function_b，在f unction_b 中，对指针 A 操作之后，执行 delete 操作，将 A 所指对象释放掉。随后，function_a 调用函数 function_c，在function_c 中又再次操作指针 A。

此时，指针 A 为空，因此，当调用A->getValue 时发生 coredump。这里存在的一个问题是编码风格不好，对象的分配使用释放混乱。

一个函数分配，一个函数释放，一个函数再次使用。导致 function_c 不知道前面 A 已经被释放。避免这种问题的一个办法是：编码时遵循“谁分配，谁释放”的原则。即对象在哪里分配，就在哪里释放。

**正确代码**

```cpp
void function_a() {
	MyClass *A = new MyClass (1);
	function_b(A);
	function_c(A);
    delete A;
    A= NULL;    
}

void function_b(MyClass *& A) {
	MyClass *B = new MyClass(2);
    A->getValue();		// 不释放 A，让函数 a 来释放
	B->getValue();
    delete B;
    B = NULL;
}
```



### 6.9 重复申请内存未释放

**代码示例**

```cpp
unsigned char* Func(void)
{
	unsigned char *stra;
	stra = (unsigned char *) malloc (10);
	return stra;
}

int main()
{
	unsigned char *strb;
	strb = Func();
	strb = (unsigned char *) malloc (10);
	free(strb);
	return 0;
}
```

**现象&后果**

用一个指针指向两次动态分配的内存，但只 free 一次，造成内存泄露。使用 cppcheck 工具检测，可以得到类似下面的信息：(error)Memory leak: strb。

**Bug分析**

Func 函数中申请了内存赋值给 strb，然后在 main 函数中又动态分配了内存赋值给 strb。在 free(strb) 时，实际只是释放了最后一次动态申请的内存，Func 函数中申请的内存被漏掉了。第一次申请的内存没有被释放，造成内存泄露。

**正确代码**

```cpp
int main()
{
	unsigned char *strb;
	strb = Func();
	free(strb);
	strb = (unsigned char *) malloc (10);
	free(strb);
	return 0;
}
```

**编程建议**
这是一个小问题。两次动态分配的内存，但只 free一次，造成内存泄露。记得申请释放内存时要注意 malloc 和free 配对，申请几次释放几次。



### 6.10 delete与delete[]的区别

**代码示例**

```cpp
char *buff = new char[reslen];
delete buff;
```

**现象&后果**

申请的数组空间没有全部释放，造成内存泄露。用 cppcheck 工具执行静态代码扫描可以看到如下信息: (error) Mismatchingallocation and deallocation: buf。

**Bug分析**

对于数组类型，如 string \*str = new string[10]，用 delete str 和 delete[] str 的区别是，delete str 只对 str[0] 调用了析构函数，而 delete []str 则对 str 数组里的每个元素都调用了析构函数。对于单个元素，如 int*p=new int (10) , delete 和 delete[] 都可以释放内存。

**正确代码**

```cpp
char *buff = new char[reslen];
delete[] buff;
```

**编程建议**
操作内存的时候，new[] 一定要和 delete[] 对应。



### 6.11 函数中途退出忘记释放内存

**代码示例**

```cpp
int func(char* in, int inlen)
{
	char *p = new char[20];
    if ( inlen < 20 ) {
		return 0;
	}
	strncpy(p, in, 20);
    delete[] p;
	return 1;
}
```

**现象&后果**

若 inlen<20，则函数中途退出，而未释放内存，导致内存泄露。

**Bug分析**

上述代码中，func 函数内 new 了一块内存，在 if 条件分支中，没有释放内存，就直接 return 0，致使函数在条件分支中退出，导致了内存泄露。

**正确代码**

```cpp
int func(char* in, int inlen)
{
	char *p = new char[20];
    if ( inlen < 20 ) {
    	delete[] p;
		return 0;
	}
	strncpy(p, in, 20);
    delete[] p;
	return 1;
}
```



### 6.12 二维数组的内存泄露

**代码示例**

```cpp
int main()
{
	int **pVal = new int*[2];
	for(int i = 0; i < 2; i++) {
		pVal[i] = new int[3];
	}
	delete[] pVal;
	return O;
}
```

**现象&后果**

二维数组的释放，没有将每个元素逐一释放，造成内存泄露。使用 valgrind 检测工具检测,可以得到类似的信息，LEAK SUMMARY:definitely lost: 24 bytes in 2 blocks。

**Bug分析**

泄露点在 delete [] pVa, pVal 是 2*3 的二维数组指针， delete[] pVal 只释放了pVal 所指向的行空间，没有释放每个 pVal[i] 所指向的列空间。

**正确代码**

```cpp
int main()
{
    int **pVal = new int*[2];
    for(int i = O;i < 2; i++)
        pVal[i] = new int[3];
    for(int j = 0; j < 2; j++)
        delete[] pVal[j];
    delete[] pVal;
    return 0;
}
```



### 6.13 临时变量内存不能返回

**代码示例**

```cpp
char *initialize() {
	char str[300];
    char* ptr = str;
    return ptr;
}

void useMyStr(char * str) {
    char tmp[300] = "123";
    printf("%s\n", tmp);
    printf(" %s\n" , str);
}

int main() {
	char *myStr = initialize();
	useMyStr(myStr);
	return 0;
}
```

**现象&后果**

返回的指针将指向一个不确定内容的地址。

**Bug分析**

在函数 initialize 中的本地变量 char 数组分配的内存在栈上，随着函数的返回会被收回。正确的做法是：返回指针对应的内存块需要用函数 malloc 动态分配。

**正确代码**

```cpp
char *initialize() {
	char *myStr = (char*)malloc(300);
	return ptr;
}

int main() {
	char *myStr = initialize();
	if(myStr != NULL)
		useMyStr(myStr);
	delete myStr;
	return 0;
}
```



### 6.14 正确使用引用参数和引用返回值

**代码示例**

```cpp
int &add(int n, int m) {
	n = n + m;
	return n;
}

int main() {
	int i = 10;
	int b = add(i,1);
    cout << b << endl;
	return 0;
}
```

**现象&后果**

预期的输出结果是 11，但实际输出的结果不确定。

**Bug分析**

add 函数是一个函数引用，而 add 函数的返回值是形参 n，形参是函数内的局部变量，函数执行结束之后，函数内的局部变量就被销毁，内存空间就被收回。因此, add 函数返回的内存单元中的值就不确定，b 的内容就不确定。正确方法是：确保返回的内存空间不会随着函数的调用结束、被回收。

**正确代码**

```cpp
int &add(int &n, int m) {
	n = n + m;
	return n;
}
```



### 6.15 试图产生的指针很可能不存在

**代码示例**

```cpp
void func(const int* plnt, size_t size) {
	size = *plnt;
	cout << "size:" << size << endl;
}

int main() {
	vector<int> vecInt;
    func(&vecInt[0]，4);
    return O;
}
```

**现象&后果**

程序运行时，产生core dump。

**Bug分析**

在程序中，vector\<int> vecInt 定义了一个没有初始化的 vector 变量 veclnt，因此, vecInt 只是一个没有内存空间的空 vector 对象。调用函数 func 时，&vecInt 作为参数，此时就产生了一个不存在的指针。因此，在函数 func内对其进行取值操作时，导致程序 core dump。

**正确代码**

```cpp
int func(const int* plnt, size_t size) {
    if (plnt == NULL) 
        return -1;
}
```

**编程建议**
使用指针前需要判断指针是否为 NULL，避免空指针导致的程序异常。



### 6.16 结构体成员内存对齐问题

**代码示例**

```cpp
struct {
	char flag;
    int i;
} foo;

int main()
{
	foo.flag = 'T';
	int *pi = (int *)(&foo.flag + 1);
    *pi = 0x01020304;
	printf("flag = %c，i = %x \n",foo.flag, foo.i);
	return 0;
}
```

**现象&后果**

代码中定义了一个结构体，包括一个字符成员 flag 和整型成员 i。在 main 函数中想通过指针方式将结构体整型成员i赋值为 0x01020304，但打印输出显示i的实际值为 0x01，赋值错误。

**Bug分析**

上面程序的问题出在指针赋值处，即 int *pi= (int *)(&foo.flag+1)。程序员误以为结构体字符成员 flag 地址加 1 就是整型成员 i 的地址，然后给该地址赋值，期望变量 i 会得到相应的赋值。但赋值结果并非所期望的。导致这个问题的根源是内存字节对齐。

内存字节对齐是指，为了保证 CPU 对内存的访问效率，各种类型数据需要按照一定的规则在内存存放，而不是完全字节挨字节的顺序存放。每种数据类型的默认对齐长度依赖于编译器具体实现，不同编译器可能有所不同。大多数情况下，基本数据类型的对齐长度就是自己数据类型所占空间大小(sizeof值)。例如，char 型占一个字节，那么对齐长度就是一个字节; int 型占 4 个字节，对齐长度就是 4 个字节，double 型占 8 个字节，对齐长度就是 8 个字节。

对于结构体数据类型，默认的字节对齐一般需满足 3 个准则。

1. 结构体变量的首地址能够被其最宽数据类型成员的大小整除。
2. 结构体每个成员相对结构体首地址的偏移量都是该成员本身大小的整数倍，如有需要会在成员之间填充字节。
3. 结构体变量所占总空间的大小必定是最宽数据类型大小的整数倍。如有需要会在最后一个成员末尾填充若干字节，使得结构体所占空间大小是最宽数据类型大小的整数倍。

在结构体 foo 里，整型成员 i 占用 4 个字节，是占用空间最多的成员，所以 foo 必须驻留在 4 的整数倍内存地址。字符成员 flag 的起始地址即为 foo 的起始地址， flag 占用 1 个字节。整型成员 i 的起始地址因为必须是 4 的整数倍，所以不能直接存放于 flag+1 的位置(flag 已占用 1 个字节，flag+1地址不再是 4 的整数倍)，而是存放于flag+4 的位置。因此，flag 后面的有 3 个字节浪费掉了。这样 foo 一共需要占用 8 个字节的内存空间，而不是 5 个字节(char 型和 int 型的 sizeof和)。

程序中，给 flag+1地址处赋值为一个 4 字节整数 0x01020304，因为有 3 个字节并未影响到变量 i，所以赋值结果为 0x01。

**正确代码**

```cpp
// 不使用 flag 地址加 1 给变量 i 赋值，直接使用 i 的地址赋值。
int main()
{
	foo.flag = 'T';
    int *pi = &foo.i;
    *pi = 0x01020304;
	printf("flag = %c，i = %x \n", foo.flag,foo.i);
	return 0;
}
```



### 6.17 String对象何时需delete

**代码示例**

```cpp
int main() {
	string str1("stack-allocated str1");
	string str2 = "stack-allocated str2";
	string* str3 = new string(" heap-allocated str3");
	return 0;
}
```

**现象&后果**

程序在运行时发生内存泄露。

**Bug分析**

程序中使用了 string 对象的不同初始化或生成方式，容易让人迷惑，先解释一下。

- str1 是 string 对象的显式初始化，调用 string 类的构造函数 string(constchar* s ) 初始化。
- str2 是复制初始化，会首先生成一个临时 string 对象，该临时对象以所赋值字符串为输入，调用 string ( const char * s ) 构造函数生成。然后以该临时对象的引用为参数调用 string 类的复制构造函数初始化 str2。因为 str1 和 str2 对象都是在 main 函数体内声明的，所以都是分配在栈上。
- str3 是一个 string 对象指针，指向一个由 new 操作符生成的 string 对象。由于是由 new 生成的，所以该对象分配于堆上。

上述代码混淆了string 对象的用法，不知道该什么时候调用 delete 释放对象。C++ 中没有垃圾回收机制，申请动态内存空间后，使用完后必须释放掉，否则会引起内存泄露。

那什么时候必须自己显式调用 delete 语句呢?答案是，如果对象是在栈上分配的，不需要人工处理，当超出对象作用范围时，该对象的析构函数会自动被调用以释放该对象；如果对象是使用 new 操作符在堆上分配的，则必须使用 delete 操作符释放该对象。

上面代码中 str1 和 str2 都是在栈上分配的局部变量，所以，会在程序退出 main 函数前被自动析构。而 str3 是由new 操作符在堆上分配的，必须使用 delete 操作符来释放。

**正确代码**

```cpp
int main() {
	string str1("stack-allocated str1");
	string str2 = "stack-allocated str2";
	string* str3 = new string(" heap-allocated str3");
    delete str3;
	return 0;
}
```



### 6.18 小结

C/C++ 内存使用是一个深入的话题。内存使用是对内存申请、读写、释放过程的安排与统筹，从而实现内存的正确、高效使用。本章主要从正确性上讲解了内存使用的全过程，包含了常见的错误案例。希望通过本章节的内容，使读者对 C/C++ 内存使用有正确的了解和认识。