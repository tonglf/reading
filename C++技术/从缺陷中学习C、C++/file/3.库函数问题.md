## 第 3 章  库函数问题

### 3.1 sprintf函数引起的缓冲区溢出

**编程建议**
在 libc 参考手册对 sprintf 函数的说明中有一个警告，如果复制的字符串长度超过提供的 buf 串的长度，sprintf 函数会变得很危险。为了避免这个问题，可以用 snprintf 函数来代替 sprintf 函数。但在使用 snprintf 的时候，在调用这个函数之后需要对返回值作检查，如果返回值比分配的 buf长度要大，表示复制不完整，则需要重新分配大的空间之后再一次调用 snprintf 函数。

在 libc 参考手册中，也同时提到，在实际使用过程中，用 asprintf 函数代替 snprintf 函数会更方便些。asprintf 函数不需要预先分配 buf，它能在复制过程中根据实际复制源字符串的大小动态分配空间，具体可参考 libc 参考手册。



### 3.2 snprintf函数format参数的问题

**代码示例**

```cpp
int main()
{
    char buf[10] ="";
    char src[10] = "hello %s";
    int len = snprintf(buf, sizeof(buf), src);
    printf("buf=%s\n", buf);
    return O;
}
```

**现象&后果**

上述代码的字符串 src 中如果存在格式化字符串 (如本例中 src 包含 “%s”)，程序运行时最后打印出的 buf 值将是不可预期的字符串或者出现段错误 (Segmentation fault) 。

**Bug分析**

snprintf 函数本身是可变参数函数，原型如下:

```CPP
int snprintf(char* buffer, int buf_size, const char* format, ...)
```


当函数只有 3 个参数时，如果第三个参数中没有包含定义格式化的字符串，函数调用没有问题，但如果第三个参数中包含定义格式化的字符串，如例子中的 “%s”，由于没有提供第四个参数，函数将会访问一个不确定的内存地址读取内容作为这个参数的值，从而导致不可预期的输出或者段错误。正确的做法是提供完整的参数，防止出现参数遗漏的现象。

**正确代码**

```cpp
int main()
{
    char buf[10] ="";
    char src[10] = "hello %s";
    int len = snprintf(buf, sizeof(buf), "%S", src);
    printf("buf=%s\n", buf);
    return O;
}
```



### 3.3 错误使用snprintf函数返回值



### 3.4 字符串复制不完整

**代码示例**

```cpp
int main()
{
    char str[] = "ab\0c";
    char buf[5];
    strcpy(buf, str);
    int bufSize = sizeof(buf);
    printf("bufSize=%d\n", bufSize);
    for(int i=O; i<bufSize; i++)
    {
        printf(" %c\n", buf[i]);
    }
    return O;
}
```

**现象&后果**

复制到目标字符串 buf 中的内容与源字符串str中的内容不相同。

**Bug分析**

字符串在内存中是以二进制流的形式存在的，对二进制流来说 ‘\0’ 也是一个正常的 01 序列，但这个 ‘\0’ 对 C 语言的字符串来说是一个特殊的字符，它是用来标志字符串的终结符，因此，对字符串函数 strcpy 来说，其操作的范围，只是字符串的开始到它遇到的第一个 ‘\0’。故当字符串中间存在 ‘\0’ 时，‘\0’ 后面的字符就会被忽略。正确的做法是使用 memcpy 函数，这个函数是对内存的复制，如前面说的，任何字符都只是 01序列，‘\0’ 也一样。所以，如果被复制的字符数组中含有 ‘\0’，可以使用 memcpy，复制的长度由它的第三个参数决定，不会依赖 ‘\0’。

**正确代码**

```cpp
int main()
{
    char str[] = "ab\0c";
    char buf[5];
    memcpy(buf, str, 5);
    int bufSize = sizeof(buf);
    printf("bufSize=%d\n", bufSize);
    for(int i=O; i<bufSize; i++)
    {
        printf(" %c\n", buf[i]);
    }
    return O;
}
```

**编程建议**
strcpy 函数和 memcpy 函数之间的区别：strcpy 只能用于字符串复制，不需要指定长度，它遇到被复制字符串的结束符 ‘\0’ 就结束; memcpy 可用于复制任意内容，复制长度由其第三个参数决定。



### 3.5 string类的c_str方法使用不当

**代码示例**

```cpp
int main)
{
    string str = "abcd";
    const char *pcStr = str.c_str();
    printf("cStr=%s，pcStr=%p\n", pcStr, pcStr);
    str.append("efg");
    const char *pcStr2 = str.c_str();
    printf(" cStr2=%s,pcStr2=%p\n",pcStr2, pcStr2);
    return O;
}
```

**现象&后果**

在语句 “str.append("efg")” 之后，指针 pcStr 成为“野指针”，可能造成严重后果。

**Bug分析**

string 类的 c_str() 方法返回的是一个常量指针，它所指向地址的内容是不会改变的。上述代码中，在没有改变str的值之前，指针变量 pcStr 就是 str 的首地址，但当通过 append 函数对 str 追加了一些内容之后，因为 append 会先开辟一段新内存，然后再将原来的值复制过来，所以，str 的首地址已经发生了改变，而 pcStr 指向的内存实际上已经被释放，因而 pcStr 成为“野指针”。

改正的方法是，在将 str.c_str() 赋值给 pcStr 之后，不去改变 str 的值；或者当需要改变 str 的值时，使用 strcpy 函数把 str.c_str() 返回的内容复制出来，再赋值给 pcStr。下面正确代码使用的是第二种方法。

**正确代码**

```cpp
int main)
{
    string str = "abcd";
    char pcStr[20];
    strcpy(pcStr, str.c_str());
    str.append("efg");
    return O;
}
```

**编程建议**
最好使用 strcpy 函数来操作 string 类的 c_str 方法返回的指针，从而避免带来“野指针”。  



### 3.6 string类的“[]”操作符使用不正确

**代码示例**

```cpp
void messageCopy(const char* msg, size_t length, string &str)
{
    for(int i = 0; i < length; i++)
    {
        str[i] = msg[i];
    }
}

int main()
{
    char message[10] = "123456789";
    string str;
    str.reserve(10);
    messageCopy(message, 10, str);
    printf("str = %s, length = %d\n",str.c_str(), str.size());
    if (str.empty))
    {
        printf("empty message\n");
    }
    return 0;
}
```

**现象&后果**

上述代码通过 messageCopy 函数接收一个字符串，并通过 string 类的 empty 函数判断返回的字符串 str 是否为空，若为空则打印 "empty message”。但不管给的源字符串 message 是多长的字符串，程序总是打印 "empty message”，但直接打印 str.c_str() 函数的输出并不为空。

**Bug分析**

问题出在 messageCopy 函数上。在函数里面输入的源字符串 msg 的内容被逐个按字符复制给传入的目标字符串 str，确实 msg 的内容也复制到了 str 的内存空间中，这通过打印 str.c_str 函数的输出可以验证。string 对象内部维持了一段连续空间，以及表示所存字符串长度的 size。这里的问题就是，string 对象 size 的值与实际存在 string 对象中的字符串长度出现了不一致。上述代码中，虽然改动了 str 的内存空间，但并没有触发 size 的改变，而 empty() 函数只是根据原有的 size 是否为 0 作判断，而没有重新计算 str 所占内存长度，所以，造成非预期结果。

**正确代码**

```cpp
int main()
{
    char message[10] = "123456789";
    string str;
    str.reserve(10);
    str.append(message, strlen(message));
    printf("str = %s, length = %d\n",str.c_str(), str.size());
    if (str.empty))
    {
        printf("empty message\n");
    }
    return 0;
}
```

**编程建议**
在使用 string 类的时候，尽量使用 string 类内部提供的 append 函数来进行字符串追加，这个函数会对存储的值与长度进行同步。



### 3.7 不正确的字符串比较

**代码示例**

```cpp
int main()
{
    char *str_a = "hello world";
    char str_b[12];
    strcpy(str_b, str_a);
    printf("stra = %p, stra = %s\n", str_a, str_a);
    printf("strb = %p, strb = %s\n", str_b, str_b);
    if(str_a == str_b)
    {
        printf("equal! \n");}
    else
    {
        printf(" not equal! \n");
    }
    return 0;
}
```

**现象&后果**

上述代码比较两个字符串，它们内容相同，结果却输出 “not equal!”。

**Bug分析**

上述代码本来期望比较的是两个字符串是否相等，但实际上比较的是字符型指针，也就是比较的是两个指针的值，即两个字符串所存放的地址。代码中两个字符串从内容上看是相等的，但由于代码中比较的是两个字符串的指针，而两个字符串存储在不同的内存空间，所以结果必然是不相等的，因而结果不符合预期。

正确的比较方式是直接比较两个字符串。

**正确代码**

```cpp
int main()
{
    char *str_a = "hello world";
    char str_b[12];
    strcpy(str_b, str_a);
    printf("stra = %p, stra = %s\n", str_a, str_a);
    printf("strb = %p, strb = %s\n", str_b, str_b);
    if(*str_a == *str_b)
    {
        printf("equal! \n");}
    else
    {
        printf(" not equal! \n");
    }
    return 0;
}
```

**编程建议**
字符串比较一般用 string 类直接比较或者用 compare 函数。对于 C 语言的字符串，则可以用 strcmp 函数进行比较。



### 3.8 strncpy函数没有复制结束符

**代码示例**

```cpp
int main()
{
    string line = "";
    char buffer[1024];
    ifstream ifs("/etc/hosts", ifstreamin);
    if(ifs != NULL)
    {
        while(getline(ifs, line))
        {
            if(line.size() < 1024)
            {
                strncpy(buffer, line.c_str(), line.size());
                printf("%s\n", buffer);
            }
            else
            {
                printf("!!!llexceed 1024,ignore not to print!!!!");
            }

        }
    }
    ifs.close();
    return 0;
}
```

**现象&后果**

程序运行完之后，发现有些行打印出来的内容和文件不符。

**Bug分析**

上述代码问题出在 strncpy 函数使用不正确。strcpy 函数在复制结束时，不管目标地址空间是否足够(从而可能产生溢出)，都会自动在末尾加 ‘\0’，但 strncpy 函数则不同。strncpy 的原型如下:

```c
char* strncpy(char* destination, const char* source, size_t num)
```

—般第三个参数 num 取目标地址空间的长度，以确保复制不出现溢出。当 source 的字符串长度小于 num 时, strncpy 函数在复制所有 source 的字符之后，会填充剩下的空间为 ‘\0’。当 source 的字符串长度大于或等于 num时, strncpy 函数就只是复制 source 的字符，这样 destination 并不是正常的以 ‘\0’ 结尾的字符串。

上述代码中，以 line.size() 为 strncpy 函数的第三个参数，这就是 “source 的字符串长度等于 num” 的情形，这时复制结束后可能并没有正常地以 ‘\0’ 结尾，这时打印这个字符串就可能不是预期的。

正确的做法是在每行复制完之后，显式地在末尾添加 ‘\0’，或者直接用 line.size()+1作为第三个参数。

**正确代码**

```cpp
int main()
{
    string line = "";
    char buffer[1024];
    ifstream ifs("/etc/hosts", ifstreamin);
    if(ifs != NULL)
    {
        while(getline(ifs, line))
        {
            if(line.size() < 1024)
            {
                strncpy(buffer, line.c_str(), line.size() + 1);
                printf("%s\n", buffer);
            }
            else
            {
                printf("!!!llexceed 1024,ignore not to print!!!!");
            }

        }
    }
    ifs.close();
    return 0;
}
```

**编程建议**
strncpy 函数能提供比 strcpy 函数更安全的复制，但在使用时也一定要注意其使用细节，避免出现错误使用。



### 3.9 调用memcpy函数前未初始化缓冲区

**代码示例**

```cpp
int main()
{
    char buffer[10];
    memcpy(buffer, "hello wo"，3);
    printf("buffer=%s\n", buffer);
    return O;
}
```

**现象&后果**

运行程序，发现 buffer 打印出的内容除了 "hel” 之外还有其他字符。

**Bug分析**

上述代码的问题主要在于没有对 buffer 作初始化。当调用 memcpy 函数时，如果第三个参数设置的复制字节数小于 buffer 的字节数，buffer 尾部剩余字节中的内容是不可预知的，从而可能导致严重错误。所以，最好在使用memcpy 函数前调用 memset 函数，将 buffer 中所有位置初始化为 0。

**正确代码**

```cpp
int main()
{
    char buffer[10];
    memset(buffer, 0, 10);
    memcpy(buffer, "hello wo"，3);
    printf("buffer=%s\n", buffer);
    return O;
}
```

**编程建议**
memcpy 函数是纯字节复制，不管字节中的内容，并且源地址和目标地址都需要确保有大于第三个参数指定的大小，否则复制会产生溢出，此外，源地址和目标地址所指向的存储空间也不能重叠。



### 3.10 误用sizeof操作符取字符串长度

**代码示例**

```cpp
int main()
{
    char a[20] = "0123456789";
    int length = sizeof(a);
    printf("length of string is %d\n",length);
    return 0;
}
```

**现象&后果**

上述代码期望打印输出 a 字符数组代表的字符串的长度 10，但实际运行结果为 20。

**Bug分析**

上述程序中的问题在于在代码中使用 sizeof 获取字符串的长度。sizeof 操作符是用来获取占用空间大小, sizeof(a) 返回的是 a 占用的字节数。strlen 才是用来获取 C 语言字符串长度的函数，它计算从开始到第一个 ‘\0’ 之间的字符个数，但不包括 ‘\0’ 结束符。

**正确代码**

```cpp
int main()
{
    char a[20] = "0123456789";
    int length = strlen(a);
    printf("length of string is %d\n",length);
    return 0;
}
```

**编程建议**
在对 C 语言字符串进行操作时，最好统一采用 C 语言字符串函数，如 strlen。sizeof 用于获取占用空间字节数。



### 3.11 string类find函数返回值判定

**代码示例**

```cpp
int main()
{
    string s = "Alice Bob Charlie";
    size_t position;
    position = s.find("none");
    if (position >= 0)
        cout << "Found! position is : " << position << endl;
    else
        cout << "Not found!" << endl;
}
```

**现象&后果**

程序运行结果输出 “Found! position is :4294967295”，但实际上所找的字符串 "none” 并不存在于字符串 s 中。

**Bug分析**

程序的目的是，在源字符串 s 中查找目的字符串，若找到，则显示 “Found”，并返回目标子串在源字符串中的位置；反之，若未找到，则返回 “Not found" 。string.find 在未找到时会返回 string::npos。
在 C++ 中常量 npos 是这样定义的：

```cpp
static const size_t npos = -1;
```

即常量 npos 定义的值为-1。但又因为 npos 的类型 size_t 是无符号整数类型，所以 npos 实际上是一个正数，并且是 size_t 类型的最大值。

上述代码中，把 find 函数返回的值赋给 size_t 类型的变量 position，而 size_t 类型的变量 position 是永远大于等于 0，所以即使 find 返回 npos，if 条件也为 true。
正确的做法是在 if 条件中直接用 npos 作比较。

**正确代码**

```cpp
int main()
{
    string s = "Alice Bob Charlie";
    size_t position;
    position = s.find("none");
    if (position != string::npos)
        cout << "Found! position is : " << position << endl;
    else
        cout << "Not found!" << endl;
}
```



### 3.12 stringstream的清空

**代码示例**

```cpp
int main()
{
    int size = 100;
    stringstream strStream;
    for (int i = 0; i < size; ++i)
    {
        strStream << i;
        string numStr;
        strStream >> numStr;
        strStream.clear();
    }
    printf("size=%d\n",strStream.str()capacity());
    return 0;
}
```

**现象&后果**

从打印的信息看，strStream 占用的内存空间在持续增长。当 size 较大时，程序消耗内存将迅速增长。

**Bug分析**

上述代码中，在 for 循环中每次调用 strStream.clear() 是希望在每次使用完 strStream 之后清理 strStream 占用的资源，但 stringstream 的 clear 方法并没有真正地释放 strStream 占用的空间，这样 strStream 所占用的空间一直在增长。当 size 较大时，strStream 消耗的内存迅速增长，可能出现严重问题。
实际上，如果希望 strStream 释放空间，可以调用 str("") 方法来重置 stringstream 占用的内存。

**正确代码**

```cpp
int main()
{
    int size = 100;
    stringstream strStream;
    for (int i = 0; i < size; ++i)
    {
        strStream << i;
        string numStr;
        strStream >> numStr;
        strStream.str("");
    }
    printf("size=%d\n",strStream.str()capacity());
    return 0;
}
```

**编程建议**
使用 stringstream 对象可以简化类型转换，如上面例子代码中 int 到 string 的转换，但在多次转换中，使用同一个 stringstream 对象，需要使用其对象方法 str 来重置 stringstream 的 buffer，这样能确保 stringstream 占用的内存不会越积越多。



### 3.13 调用strptime函数前需初始化tm

**编程建议**
建议在调用 strptime 函数时，不管提供的时间字符串是否完整，都对 tm 结构体用 0 初始化。



### 3.14 使用feof函数的陷阱

**编程建议**

feof 函数的功能是检查一个 stream 在当前其文件结束标志是否被置位，如果已经置位，返回非零值，否则返回零。一个 stream 的文件中，fgets 函数的调用会修改文件结束标志，其他还会修改文件结束标志的类似的函数还有：fgetc、fgets、fread、fseek、getc、getchar、gets 等，所以，在使用这些函数的时候也要注意这个Bug中展示的问题。



### 3.15 for循环中调用vector容器insert函数

**代码示例**

```cpp
int main()
{
    vector<int> a;
    a.push_back(1);
    a.push_back(3);
    a.push_back(4);
    vector<int>::iterator b;
    int x = 3;
    for(b = a.begin(); b != a.end(); b++)
    {
        if(*b == x)
        {
            b = a.insert(b, 2);
        }
    }
    for(b = a.begin(); b != a.end(); b++)
    {
        printf("value=%d\n"，*b);
    }
    return 0;
}
```

**现象&后果**

上述代码在运行时陷入死循环，甚至引发 coredump。

**Bug分析**

问题主要在于对 vector 容器的 insert 函数理解不够。上述代码中所用的 vector insert 函数原型如下:

```cpp
iterator insert (iterator position, const T&x);
```

此函数在 position 迭代指示器之前插入新元素 x，返回的迭代指示器指向新加入的元素。上述代码在找到元素 3 时调用 insert 函数，在 3 之前插入元素 2，返回迭代指示器指向 2，且重新赋值给 b。b 在循环的 b++ 操作之后又指向元素 3，从而又引发 insert 函数调用，又插入另外一个元素 2，同时迭代器也指向新的元素 2。这样一直循环往复，代码陷入死循环，vector 不断膨胀，内存增长，最终可能引发 coredump。
解决方法是在调用 insert 函数之后，需要使 b 多移动一个位置，以略过新添加的元素。

**正确代码**

```cpp
int main()
{
    vector<int> a;
    a.push_back(1);
    a.push_back(3);
    a.push_back(4);
    vector<int>::iterator b;
    int x = 3;
    for(b = a.begin(); b != a.end(); b++)
    {
        if(*b == x)
        {
            b = a.insert(b, 2);
            b++;
        }
    }
    for(b = a.begin(); b != a.end(); b++)
    {
        printf("value=%d\n"，*b);
    }
    return 0;
}
```



### 3.16 multiset容器erase函数的误用

**代码示例**

```cpp
int main()
{
    multiset<int> c1;
    c1.insert(3);
    c1.insert(2);
    c1.insert(3);
    c1.insert(3);
    c1.insert(5);
    int x=3;
    c1.erase(x);	//remove one element withvalue 3
    for(multiset<int>::iterator it = c1.begin(); it != c1.end(); it++)
    {
        cout << *it << endl;
    }
    return 0;
}
```

**现象&后果**

代码期望删除一个值为 3 的元素，但实际运行结果显示删除了所有值为 3 的元素。

**Bug分析**

multiset 带一个参数的 erase 函数原型有两种。一是传递一个元素值，如上面例子代码中，这时候删除的是集合中所有值等于输入值的元素，并且返回删除的元素个数；另外一种是传递一个指向某个元素的 iterator，这时候删除的就是这个对应的元素，无返回值。用户需要根据自己的应用场景，正确调用对应的原型。例子代码中本意是想删除一个元素，但实际上是删除了所有值为 3 的元素，不符合预期。

**正确代码**

```cpp
int main()
{
    multiset<int> c1;
    c1.insert(3);
    c1.insert(2);
    c1.insert(3);
    c1.insert(3);
    c1.insert(5);
    int x=3;
    multiset<int>::iterator pos = c1.find(x);
    c1.erase(pos);	//remove one element withvalue 3
    for(multiset<int>::iterator it = c1.begin(); it != c1.end(); it++)
    {
        cout << *it << endl;
    }
    return 0;
}
```

**编程建议**
在使用 multiset 的时候，需要注意 mutilset 与普通 set 容器的主要区别，即 multiset 允许元素重复，set 不允许元素重复。这会给一些操作带来不同的影响。



### 3.17 慎用容器类erase函数的返回值

**代码示例**

```cpp
int main()
{
    multiset<int> a;
    a.insert(3);
    a.insert(2);
    a.insert(3);
    a.insert(3);
    a.insert(5);
    multiset<int>::iterator b;
    int x = 3;
    for(b = a.begin(); b! = a.end());)
    {
        if (*b == x) {
            b = a.erase(b); // compile error in g++,but pass in Visual Studio
        } else {
            b++;
        }
    }
    for(b = a.begin(); b!=a.end(); b++)
    {
        printf(" %d\n"，*b);
    }
    return 0;
}
```

**现象&后果**

上面代码在 Visual Studio 下编译运行没有问题，但是用 gcc 编译时，会出现编译错误。

**Bug分析**

在一个循环中删除容器元素的常用方法就是 b=a.erase(b)，这样可以避免迭代指示器 b 变无效。但并不是所有的容器都能这么用。

STL 容器分 Sequence Container ( vector ,deque , list ) 和 Associative Container( set , multiset , map , multimap )。C++ 标准中，Sequence Container 的 erase 函数会返回 iterator，但 Associative Container 不返回 iterator。Visual Studio C++ 中为 Associative Container 也实现了返回 iterator 的 erase。所以，例子代码在Visual Studio 中能编译通过并正常运行，但在 gcc 下却编译不通过。为了解决这个兼容性的问题，可以将语句写成 a.erase(b++)。这样实际的执行过程就是:

1. iterator temp=b;
2. b++;
3. erase(temp);

这样可以通过编译，同时也避免了迭代器失效的问题。

**正确代码**

```cpp
int main()
{
    multiset<int> a;
    a.insert(3);
    a.insert(2);
    a.insert(3);
    a.insert(3);
    a.insert(5);
    multiset<int>::iterator b;
    int x = 3;
    for(b = a.begin(); b! = a.end());)
    {
        if (*b == x) {
            a.erase(b++); // compile error in g++,but pass in Visual Studio
        } else {
            b++;
        }
    }
    for(b = a.begin(); b!=a.end(); b++)
    {
        printf(" %d\n"，*b);
    }
    return 0;
}
```

**编程建议**
编程过程中使用 STL 容器时，最好使用符合标准的函数定义，从而尽量避免兼容性的问题。



### 3.18 for循环中调用vector容器erase函数

**代码示例**

```cpp
int main()
{
    vector<int> a;
    a.push_back(3);
    a.push_back(2);
    a.push_back(3);
    a.push_back(3);
    a.push_back(5);
    vector<int>::iterator b;
    int x = 3;
    for(b = a.begin(); b != a.end); b++)
    {
        if(*b == x){
            b = a.erase(b);
        }
    }
    for(b=a.begin();b!=a.end);b++)
    {
        printf("value=%d\n"，*b);
    }
    return O;
}
```

**现象&后果**

上面代码的目的是，使用迭代器循环删除 vector 中所有的 3，但你会发现并不是所有的 3 都被删除掉了。

**Bug分析**

上述代码主要问题是对容器类 vector 的 erase 函数理解不够。代码中调用的 erase 函数在删除当前元素 b 后，返回 b 后面的元素。在上述代码的 vector 中，一开始有 3 个3，其中后两个 3 是连续的，在删除第二个 3 之后，erase 函数返回的下一个元素还是 3，然而代码运行到循环的 b++ 时，就略过了这个 3，从而造成不是所有的 3 都被删除。
正确的做法是，在删除元素的之后，由于 erase 函数已经自动跳到下一个元素，跳过接下来循环的 b++ 语句。

**正确代码**

```cpp
int main()
{
    vector<int> a;
    a.push_back(3);
    a.push_back(2);
    a.push_back(3);
    a.push_back(3);
    a.push_back(5);
    vector<int>::iterator b;
    int x = 3;
    for(b = a.begin(); b != a.end);)
    {
        if(*b == x){
            b = a.erase(b);
        } else {
            b++;
        }
    }
    for(b=a.begin();b!=a.end);b++)
    {
        printf("value=%d\n"，*b);
    }
    return O;
}
```

**编程建议**
在对容器类元素进行增、删操作时，一定要注意增、删操作的返回值和迭代器指示器是否发生变化，必要的时候需要进行修正。



### 3.19 getopt函数参数问题

**代码示例**

```cpp
int main(int argc, char* argv[])
{
    char ch;
    char dir[1024];
    memset(dir,0x0,sizeof(dir));
    while((ch = getopt(argc, argv, "d")) !=-1) {
        switch(ch) {
            case 'd':
                strcpy(dir, optarg);
                break;
            default:
                break;
        }
    }
    printf(" dir=%s\n" , dir);
    return 0;
}
```

**现象&后果**

将上述代码编译成可执行文件 example，带参数运行 (/example -d /tmp)，程序出现段错误 (Segmentation fault)。

**Bug分析**

上述代码的目的是，通过命令行参数 -d 指定一个必须输入的目录参数，解析得到目录后，供后续处理使用。
getopt 函数的原型为 

```cpp
int getopt(int argc, char *const argv[],const char *optstring)
```

getopt函数处理以 ‘-‘ 开头的命令行参数，optstring有以下几种形式。

1. 单字符：表示一个选项，该选项没有对应值，如 optstring="a"。
2. 单字符紧跟冒号:该选项后必须跟一个选项值。选项值可以紧跟在选项后，也可以用空格与选项字符隔开，如optstring= “b:”。
3. 单字符后紧跟两个冒号:该选项所跟参数是可选的。这个是GNU的扩展实现。有些getopt版本可能不支持该类型的参数，如optstring= “c::”。

但是，上述代码中，在为getopt指定optstring时错误地使用“d”，而不是“d:”。这样导致代码进入case 'd’之后，由于optarg为 null，执行strcpy(dir,optarg)时出现段错误。

**正确代码**

```cpp
int main(int argc, char* argv[])
{
    char ch;
    char dir[1024];
    memset(dir,0x0,sizeof(dir));
    while((ch = getopt(argc, argv, "d:")) !=-1) {
        switch(ch) {

            case 'd':
                if(optarg!=NULL && dir != NULL) { 
                    strcpy(dir, optarg);
                } else {
                    printf("optarg or dir is null\n");
                }
                break;
            default:
                break;
        }
    }
    printf(" dir=%s\n" , dir);
    return 0;
}
```



### 3.20 不用errno判断系统调用是否成功

**代码示例**

```cpp
int main()
{
    int ret = write(100,"1"，1);
    printf("ret:%d,errno: %d\n", ret, errno);
    int fd = open("errno.txt"，O_RDWR | O_CREAT,0666);
    if (fd < 0 || errno != 0) //系统调用正确errno没有被置成零，会保存上一次错误的情况
    {
        printf("error: fd: %d, errno: %d\n", fd, errno);
    }
    else
        printf( "right: fd: %d, errno: %d\n", fd, errno);
    return 0;
}
```

**现象&后果**

上述代码的期望输出是 “error”，但实际输出是 “right”。

**Bug分析**

C 语言中，errno 是一个 int 型的变量，用来记录系统的最后一次错误代码。只有在库函数调用失败时，errno 才会被赋值，当函数成功运行时，errno 的值不会被修改。
因此，在上面的代码中，写失败后，errno 就保存了失败的错误代码9, open 运行成功后，errno 没有被重新赋值，依然是 9，导致 if 条件成立，输出结果并非预期。

解决的方式是去掉对 errno 值的检查。

**正确代码**

```cpp
int main()
{
    int ret = write(100,"1"，1);
    printf("ret:%d,errno: %d\n", ret, errno);
    int fd = open("errno.txt"，O_RDWR | O_CREAT,0666);
    if (fd < 0) //系统调用正确errno没有被置成零，会保存上一次错误的情况
    {
        printf("error: fd: %d, errno: %d\n", fd, errno);
    }
    else
        printf( "right: fd: %d, errno: %d\n", fd, errno);
    return 0;
}
```

**编程建议**
在判断有返回值的系统调用是否成功的时候不能通过 errno 来判断，要通过返回值来判断。



### 3.21 strcat函数造成的段错误

**代码示例**

```cpp
int main()
{
    char dest[7] = "12345";
    char* src = "abcdefghigklmnopqrstuvwxyz";
    strcat(dest, src);
    cout << "dest:" << dest c < endl;
    return 0;
}
```

**现象&后果**

程序运行时把字符串 src 添加到目标字符串 dest 之后时会溢出，可能导致段错误 (Segmentation fault) 。

**Bug分析**

上段代码中定义了一个 char 型数组 dest，然后调用 strcat 函数把字符串 src 追加到 dest 中去。strcat 数的原型是

```CPP
char*strcat(char*dest, char*src)
```

功能是把 src 所指字符串添加到 dest 结尾处(覆盖 dest 结尾处的 ‘\0’ )并添加 ‘\0’。这就要求 dest 必须有足够的空间来容纳 src 的字符串。但是，上述代码在追加前没有判断 src 字符串的长度，而实际上 src 字符串的长度已经超过 dest 的内存空间，可能导致段错误。

**正确代码**

```cpp
int main()
{
    char dest[100]="12345";
    char* src = "abcdefghigklmnopqrstuvwxyz";
    if(strlen(dest) + strlen(src) < 100)
    {
        strcat(dest, src);
    }
    cout << "dest:" << dest << endl;
    return 0;
}
```

**编程建议**
在操作指针时，一定要保证在指针有效内存空间内操作，避免访问未分配的空间而出现段错误。



### 3.22 危险的strdup函数

**代码示例**

```cpp
void printDup(char *str)
{
    char *tmp = strdup(str);
    printf("%s\n",tmp);
}
int main()
{
    char *ptr = "Hello World!";
    printDup(ptr);
    printf("Command to check memleak:valgrind --tool=memcheck--leak-check=yes /a.out\n");
    return 0;
}
```

**现象&后果**

程序运行一切正常，但用内存检查工具查看时，发现有内存泄漏发生，strdup 分配的内存没有被释放。

**Bug分析**

这里的内存泄漏主要与 strdup 函数有关。strdup 用来实现字符串复制，它的 glibc 参考实现如下:

```CPP
char * _strdup (const char *s)
{
    size_t len = strlen (s) + 1;
    void *new = malloc (len);
    if (new == NULL)
        return NULL;
    return (char *)memcpy(new, s, len);
}
```

由 strdup 函数实现代码可以看到，strdup 会自动分配内存空间，并复制字符串。但 strdup 只 malloc 了内存，并没有释放。释放 strdup 内部动态分配的内存需要由调用者去做，这点在 strdup 的 man 手册里明确提到。

一般大家都比较清楚 malloc/free 要成对使用，但 strdup 把动态分配内存的事实隐藏在自己内部，如果使用者不了解这个细节，就会造成内存泄漏。

正确的做法是，strdup 返回的字符串在使用完之后要及时用 free 释放掉。

**正确代码**

```cpp
void printDup(char *str)
{
    char *tmp = strdup(str);
    printf("%s\n",tmp);
    free(tmp);
}
```

**编程建议**
由于 strdup 函数有容易忘记释放内存的风险，不推荐使用它。如果想做字符串复制操作，建议直接使用 malloc 函数加 memcpy 函数。



### 3.23 小结

以上问题都是由于对库函数的功能、参数的意义、返回值的意义，以及使用注意事项等不了解或者不熟悉造成的。要避免这类问题，我们在使用过程中要养成查阅 libc 参考手册的习惯，了解库函数使用的方方面面，在实践中积累经验。