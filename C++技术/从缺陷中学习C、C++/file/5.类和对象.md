## 第 5 章  类和对象

### 5.1 对象的浅复制

**代码示例**

```cpp
class IntList {
    public:
    static const int SIZE = 10;
    int *ltems;
    int numltems;
    int arraySize;
    public:
    IntList() {
        ltems = new int[SIZE];
        numltems = O;
        arraySize = SIZE;
    }
    ~IntList() {
        cout << "delete" << endl;
        delete ltems;
        ltems = nullptr;
    }
};

void do_some_process(IntList *list) {
    IntList tmp;
    // do something else
    *list = tmp;
}

int main() {
    IntList list;
    cout << "Items : " << *list.ltems << endl;
    do_some_process(&list);
    cout << "Items : " << list.ltems[0] <<endl;
    return 0;
}
```

**现象&后果**

程序运行时出现段错误。

**Bug分析**

如果类中没有对 “=” 操作符重载或没有提供赋值构造函数，那么对象间的复制只是浅复制 (shallow copy)，浅复制的意思就是 C++ 只会对对象中的每个成员使用赋值运算符。当类很简单的时候 (如没有动态分配内存的情况)，浅复制不会出问题。但是如果其中一个类成员变量为指针变量，并且指向动态分配的空间，那么在赋值之后，被赋值的对象的指针变量将会指向原对象动态分配的空间，因此原对象被析构之后，被赋值对象的指针就变成悬挂指针。

上述代码中，do_some_process 函数中两个对象之间的赋值操作 *list = tmp 只是将对象 tmp 的内存内容复制给对象 list，因此，两个对象的指针成员 ltem 都指向了同一片地址。当 do_some_process 函数退出时，因 tmp 是函数内临时对象，它的生命周期也结束，这时会调用析构函数释放掉 tmp 所占用的内存，包括 ltem 所指向的地址，导致 list 成员 ltem 成为一个野指针，一旦操作这个野指针就可能会造成程序崩溃。

**正确代码**

```cpp
// 在类IntList中重载“=”操作符，如下 
IntList & operator=(const IntList &l) {
    this->numltems = l.numltems;
    this->arraySize = l.arraySize;
    memcpy(this->ltems, l.ltems, sizeof(int) * this->numltems);
    return *this;
}

// 重载拷贝构造函数
IntList(const IntList &l) {
    this->numltems = l.numltems;
    this->arraySize = l.arraySize;
    this->ltems = new int[SIZE];
    memcpy(this->ltems, l.ltems, sizeof(int) * this->numltems);  
}
```



### 5.2 构造函数中的操作符重载

**代码示例**

```cpp
class MyClass{
private:
    int data;
public:
    MyClass(void) {data = 0;}
    MyClass(const MyClass &i_class){
        cout << "construct MyClass" << endl;
        *this = i_class;
    }
    MyClass operator=(const MyClass &i_class){
        cout << "operate=" << endl;
        data = i_class.data;
        return *this;
    }
    void put(const int value){
        data = value;
    }
    int get(){
        return data;
    }
};

int main(){
    cout << "main" << endl;
    MyClass first;
    first.put(10);
    MyClass second(first);
    cout << "second get " << second.get() << endl;
    return 0;
}
```

**现象&后果**

程序编译没有问题，但是执行时陷入死循环。

**Bug分析**

在C++中，如果一个函数返回值 (非引用) 时，会生成一个匿名的临时变量并将函数返回值赋值给匿名的临时变量;如果函数返回引用，则不会生成临时变量。例如：int func() 函数的返回值为 int 型，在执行 int n = func() 语句时会首先生成一个匿名的临时变量，并将函数 func() 的返回值赋值给匿名的临时变量，然后再将匿名的临时变量值赋值给 n。这里有两次赋值的操作。int &func() 函数的返回为引用，在执行 int n = func() 语句时，会把返回引用直接赋值给 n，这里只有一次赋值的操作。

在上段代码中，MyClass 类定义了两个构造函数和一个操作符重载函数，在构造函数 MyClass(const MyClass &i_class) 中，两个对象赋值时会调用操作符重载函数。调用操作符重载函数后会生成临时变量，并把操作符重载函数的返回值赋值给临时变量，这个过程会再次调用构造函数 MyClass(const MyClass&i_class) 和操作符重载函数 operator=，从而导致反复调用构造函数及操作符重载函数，程序陷入死循环。

解决这个问题，只需把操作符重载函数的返回值类型改成返回引用类型即可。

**正确代码**

```cpp
// 把操作符重载函数的返回值类型改成返回引用类型
MyClass& operator=(const MyClass &i_class){
    cout << "operate=" << endl;
    data = i_class.data;
    return *this;
}
```



### 5.3 拷贝构造函数不能模板化

**代码示例**

```cpp
template<unsigned int size>
class myvector
{
public:
    myvector() { data_ = new int[size]; }
    ~myvector() { delete[] data_; }
    template<unsigned int size1>
    myvector(const myvector <size1> &other)
    {
        data_ = new int[size];
        int i = 0;
        for(; i < size && i < size1; i++)
            data_[i] = other[i];
        for(; i < size; i++)
            data_[i] = 0;
    }
    int &operator[](int i) {return data_[i];}
    const int&operator[](int i) const { return data_[i]; }
private:
    int *data_;
};
int main()
{
    myvector<2> vector2;
    vector2[0] = 1;
    vector2[1]= 2;
    myvector<3> vector3(vector2);
    for(int i = 0; i < 3; i++)
        cout << vector3[i] <<" ";
    cout << endl; 			// Prints 1 2 0
    myvector<3> other3(vector3);
    for(int i = 0; i < 3; i++)
        cout < < other3[i] <<"";
    cout<< endl; 			// Prints 1 2 0
}
```

**现象&后果**

main函数结束时出现段错误。

**Bug分析**

模板类 myvector 中定义了一个转换构造函数 (conversion-constructor ) ，将 template\<unsigned int size1> 类型转换为 template\<unsigned int size>。在 main 函数中将 vector2 转为 vector3 时，会调用此转换构造函数，接下来将 vector3 转为 other3，这时并没有调用转换构造函数，因为它们类型相同，所以会去调用拷贝构造函数，而模板类中并没有定义拷贝构造函数，故调用了默认的拷贝构造函数。由于是简单的浅拷贝，vector3 和other3 的成员指针变量 data\_ 指向同一片内存，在 main 函数退出时，模板类的析构函数先后对 vector3 和 other3 对象的成员 data_ 进行 delete，导致 double free 的内存错误。

模板化的构造函数永远不会被编译器当做拷贝构造函数来使用，只会以转换构造函数的形式存在。因此，要想自定义的拷贝构造函数生效，就不能对其模板化。

**正确代码**

```cpp
// 在模板类中加上拷贝构造函数:
myvector(const myvector &other)
{
    data_ = new int[size];
    for(int i = 0; i < size; i++)
        data_[i] = other[i];
}
```



### 5.4 析构函数未捕获异常引发coredump

**代码示例**

```cpp
class Foo{
private:
    bool flag;
public:
    Foo(void):flag(false){};
    ~Foo() {
        if (flag == true) 
            throw "UnexpectedException!";
    }
    void set_flag(bool value){ flag=value; }
};

int main() {
    try{
        bool unexpected_condition = false;
        Foo foo;
        foo.set_flag(true);
        unexpected_condition = true;
        if (unexpected_condition)
            throw new string("Error:unexpected condition.");
    } catch(...) {
        cout << "Exception caught."<< endl;
    }
    return 0;
}
```

**现象&后果**

main函数中抛出异常后，在异常处理时失败，引发coredump。

**Bug分析**

C++ 异常处理机制为程序员提供了一种处理运行时错误的方式，允许程序员以更自然灵活的方式处理错误。当一个函数发现自己无法处理某个错误时，可以抛出一个异常，由它的调用者捕获和处理，调用者可以决定立即处理还是将问题再次抛出，或者终止程序。这样把正常执行代码和错误处理区分开来，比传统的通过检查函数返回值的方式更灵活方便。如果抛出的异常未被捕获，则会一直向上传递直到 C++ 自动调用标准库中的 terminate 函数，默认情况下 terminate 会再次调用 abort 函数结束程序，同时生成 coredump。

当一个异常抛出时，程序控制权从 try 代码块转移到 catch 异常处理代码块，C++ 运行时会调用所有从 try 语句开始到 throw 语句之间构造起来的本地自动对象的析构函数，销毁这些对象，回收它们所占用的空间。这个过程被称为“栈展开”(stack unwinding)。栈展开时销毁对象的顺序与构造这些对象的顺序相反。如果在栈展开的过程中，某个对象的析构函数又抛出了异常并且这个异常未被捕获，C+＋会调用 terminate() 函数，该函数默认调用abort() 函数以非正常方式结束程序。此时程序被异常结束。

上面代码中，main 函数中的 try 代码块抛出异常时，在栈展开的过程中调用 foo 的析构函数尝试销毁 foo，但在foo 的析构函数中再次抛出了异常并且未捕获，导致 C+＋调用 terminate 函数进而调用 abort 函数异常终止程序，并生成coredump。
**C++ 标准中没有禁止在析构函数中抛出异常，但从设计原则上来讲，析构函数应该杜绝抛出异常。**析构函数中抛出异常往往是预示着这可能是一个 Bad Design。如果析构函数非要抛出异常，或者调用了其他可能会抛出异常的函数方法，则析构函数应自己捕获这些异常。

**正确代码**

```cpp
class Foo{
private:
    bool flag;
public:
    Foo(void):flag(false){};
    ~Foo() {
        if (flag == true) 
            cout << "Bad exception!" << endl;
    }
    void set_flag(bool value){ flag=value; }
};
```



### 5.5 构造函数中抛出异常引起内存泄露

**代码示例**

```cpp
class Foo{
    private:
    char* array;
    public:
    Foo(int flag) {
        array = new char[1024];
        if (flag) {
            throw runtime_error( "Exception thrown." );
        }
    };
    ~Foo() {
        delete[] array;
    }
};

int main()
{
    try {
        Foo foo(10);
    } catch ( const exception& e ) {
        Cout<< "Exception caught." <<endl;
    }
    return 0;
}
```

**现象&后果**

程序编译运行正常，当用内存泄漏检查工具valgrind检查时，报告说有内存泄露发生。

**Bug分析**

从设计原则上来讲，在析构函数中不建议抛出异常，但在构造函数中，在构造失败的情况下抛出异常却是一种常见行为。但在构造函数中抛出异常需要注意，因为在类的构造函数中抛出异常，系统是不会调用它的析构函数的，可能会造成资源泄露，所以，在构造函数中抛出异常前要记得释放已经申请的资源。上面代码中，在 Foo 的构造函数中动态分配了一个字符数组，随后抛出了一个异常。异常抛出时该动态数组并没有被释放，Foo 的析构函数也不会被调用，因而发生内存泄露。

**正确代码**

```cpp
// 在抛出异常前释放已分配内存。
class Foo{
    private:
    char* array;
    public:
    Foo(int flag) {
        array = new char[1024];
        if (flag) {
            delete[] array;
            throw runtime_error( "Exception thrown." );
        }
    };
    ~Foo() {
        delete[] array;
    }
};
```

**编程建议**
其实不光在类的构造函数中，在其他地方，如一个函数中，也可能出现类似的情况。在抛出异常前，必须先释放前面已申请的资源，否则会引起资源泄露。这个资源包括已申请的内存、打开的文件描述符、打开的网络套接字等。



### 5.6 多态性未生效

**代码示例**

```cpp
class Parent
{
public:
    void foo() {
        cout << "foo from parent" << endl;
    }
};

class Son : public Parent
{
	void foo() {
		cout << "foo from son" << endl;
	}
};

void CallFoo(Parent *temp)
{
    temp->foo();
}


int main() {
    Parent *p = new Parent();
    Son *s = new Son();
    CallFoo(p);
    CallFoo(s);
    delete p;
    delete s;
    return 0;
}
```

**现象&后果**

两次输出的结果都是“foo from parent".

**Bug分析**

上述代码的本意是想通过 CallFoo 函数，传递不同类型对象的指针，分别调用不同类型的 foo 成员函数，但是程序的运行结果却出乎意料，系统分不清楚传递过来的是基类对象还是派生类对象，无论是基类对象还是派生类对象调用的都是基类的 foo 成员函数。产生这个现象的原因是：如果基础类和衍生类都定义了「相同名称的成员函数」，那么透过对象指针调用成员函数时，到底调用到哪一个函数，必须视该指针的原始类型而定，而不是指针实际所指对象的类型而定。为了解决上述问题，C++ 提供了一种叫做多态性(polymorphism)的技术。在运行时，根据其类型确定调用那个重载的成员明委的有,称为多态性。实现多态的关键是使用虚函数，virtual 关键字修饰的成员函数，就是虚函数，其作用是“推迟联编”或者“动态联编”，即一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。将上述基类的成员函数 foo 改为虚函数，即可实现多态。

**正确代码**

```cpp
class Parent
{
public:
    virtual void foo() {
        cout << "foo from parent" << endl;
    }
};
```



### 5.7 基类成员函数被隐藏

**代码示例**

```cpp
class Parent{
public:
    void fun() { cout << "Parent::fun()" <<endl; }
    void fun(int i) { cout << "Parent::fun(inti)" << endl; }
};

class Son : public Parent {
public:
    void fun(int i, int j) { cout<< "Son::fun(int i, int j)" << endl; }
    void fun2() { cout << "Son::fun20" << endl}
};

int main()
{
    Son s;
    s.fun(1,2);
    s.fun2();
    s.fun();
    s.fun(1);
    return O;
}

```

**现象&后果**

编译时产生错误。提示如下的错误信息: 

nomatching function for call to\`Son::fun)'

nomatching function for call to`Son::fun(int)'

**Bug分析**

上述的错误是由于派生类隐藏了基类的 fun() 和 fun(int i) 函数导致。

成员函数的重载、覆盖(override) 与隐藏很容易混淆，先分别介绍一下各自的特征。
重载的特征:

1. 相同的范围(在同一个类中);
2. 函数名字相同;
3. 参数不同;
4. virtual关键字可有可无。

覆盖是指派生类函数覆盖基类函数，特征是:

1. 不同的范围(分别位于派生类与基类);
2. 函数名字相同;
3. 参数相同;
4. 基类函数必须有virtual关键字。

隐藏的特征如下:

1. 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual
    关键字，基类的函数将被隐藏(注意别与重载混淆)。
2. 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混滑）。

上例中，派生类 Son 中有基类 Parent 的同名函数 fun 的声明，则基类 Parent 中的同名函数 fun 不会作为候选函数，即使基类有不同的参数表的多个版本的重载函数 fun()、fun(int) 都被隐藏。所以，在一般情况下，想在派生类中使用新的函数版本又想使用基类的函数版本时，应该在派生类中重写基类中的所有重载版本，或者显式声明基类名字空间作用域。

**正确代码**

```cpp
class Son : public Parent {
public:
    using Parent::fun;
    void fun(int i, int j) { cout<< "Son::fun(int i, int j)" << endl; }
    void fun2() { cout << "Son::fun20" << endl}
};
```



### 5.8 匿名对象引起的内存泄露

**代码示例**

```cpp
int main()
{
    cout << (*new string("Hello")) <<endl;
	return 0;
}
```

**现象&后果**

上面代码可以正常编译运行，但用内存检查工具valgrind查看时，会报告说有内存泄露发生。

**Bug分析**

在C++中，用 new 生成一个对象，就在内存堆 (heap）中给它分配了空间。如果在程序运行结束之前没有用delete 来销毁该对象，释放它所占用的空间，就会发生内存泄露。C++ 标准并没有定义匿名对象的概念，我们这里借用“匿名对象”术语是指 new 了一个对象，但没有引用或对象指针指向它。

上面代码中，在输出语句 cout 中声明了一个临时 string 类型对象，没有指针指向它，在程序退出前也没有 delete 该对象。程序员本以为只是定义一个临时 string 对象输出一点内容，但却没想到这样一个小地方却引起了内存泄漏。而且，像这样没有指针或引用指向的匿名对象，即使后面想释放该对象也没有办法。

**正确代码**

```cpp
int main()
{
    string* tmp = new string("Hello");
    cout << *tmp << endl;
    delete tmp;
    return 0;
}
```



### 5.9 基类非虚析构函数引发内存泄露

**代码示例**

```cpp
class Base
{
public:
    virtual void dostuff(){}
};

class Child : public Base
{
private:
	string str;
public:
	Child( string& s)
	{
		Str = s;
	}
	virtual void dostuff(){}
};

int main()
{
    string hello = "Hello world!";
    Base * base = new Child(hello);
    if( base != NULL )
    {
        delete base;
    }
    return 0;
}
```

**现象&后果**

上面代码编译运行正常，但用内存检查工具valgrind查看时，会报告说有内存泄露发生。

**Bug分析**

在上面代码中，定义了基类 Base 和子类 Child，在 main 函数中，声明了一个基类指针 base 指向一个 Child 子类对象，这样能方便地利用面向对象编程的多态性。最后，通过该基类指针 base 删除 Child 对象。但问题是：在删除过程中发生了内存泄露。

代码中基类 Base 没有定义析构函数，编译器会自动为该类生成一个默认的析构函数，默认的析构函数是非虚拟的。问题的根源就在于 Base 没有一个虚析构函数。C++ 标准规定，当一个派生类对象通过使用一个基类指针删除，如果这个基类的析构函数是非虚的，则删除结果是未知的。现实中大多情况是，子类的析构函数不会被调用，因此，对象的派生部分不会被销毁，引起内存泄露。

解决这个问题的办法就是将基类的析构函数定义为虚函数。这样，通过删除基类指针释放派生类对象时，派生类的析构函数就会被调用，释放全部内存。

**正确代码**

```cpp
class Base
{
public:
    virtual ~Base(){}
    virtual void dostuff(){}
};

class Child : public Base
{
private:
	string str;
public:
	virtual ~Child(){}
	Child( string& s)
	{
		Str = s;
	}
	virtual void dostuff(){}
};
```

**编程建议**
C++ 提供虚函数主要是为了实现多态性。如果一个基类被设计用于多态处理，则应将这样的基类的析构函数声明为虚函数。这样，用基类指针指向动态分配的派生类对象，析构时就可以根据指针指向的实际类型调用相应的析构函数。



### 5.10 删除void*指针引发内存泄露

**代码示例**

```cpp
class Foo
{
public:
    Foo(char* name)
    {
        m_name = name;
        m_data = new char[100];
    };
    ~Foo()
    {
        delete[] m_data;
    };
private:
    char* m_data;
    char* m_name;
};

void GeneralDelete(void* ptr)
{
    delete ptr;
}

int main(int argc, char* argv[])
{
    Foo* foo = new Foo("foo");
    GeneralDelete(foo);
    return O;
}
```

**现象&后果**

上面代码编译正常，运行时，用内存泄露检查工具 valgrind 查看时，valgrind 会报告说有内存泄露发生。

**Bug分析**

上面代码中定义了一个用于释放对象的函数 GeneralDelete，用来统一释放程序中动态分配的对象。该函数的输入参数声明为 void\* 类型，表示不管传进什么类型的对象，都能统一的释放。这里，在调用 GeneralDelete 释放 foo 对象时，首先将它转换为 void\*类型，再 delete。但问题就出在这里，删除 void* 类型的 foo 导致了内存泄露。这是因为，当使用 delete 操作符进行释放对象时，delete 需要根据类型信息正确地释放指针所指向的内存块。操作符 delete 的工作原理大概可以用如下伪代码表示:

```cpp
delete(obj *ptr)
{
    call_destructors(ptr);
    free(ptr);
}
```

即首先调用对象的析构函数，然后释放该对象指针。在调用对象的析构函数前，首先需要知道该对象的类型。如果不知道该对象的类型，则无法知道该调用谁的析构函数。

由于对象 foo 为 void\* 空类型，delete 不会调用任何析构函数，所以，构造函数中动态分配的内存并没有被释放，导致内存泄露。

另外，C++ 标准明确说明，针对 void\*指针做 delete 操作会引发无定义行为。所以，尽量不要将一个普通对象转换为 void* 类型，也不要对 void\*对象做 delete 操作。

**正确代码**

不用 GeneralDelete 函数，在释放 Foo 对象时不将 Foo 类型转为 void* 类型，直接使用 delete 删除:

```cpp
int main(int argc, char* argv[])
{
    Foo* foo = new Foo("foo");
    delete foo;
    return 0;
}
```



### 5.11 STL容器不会自动释放指针指向的对象

**代码示例**

```cpp
class Foo
{
public:
    int i;
    Foo():i(1) {}
};

int main()
{
    vector<Foo*> fooVector;
    for( int Index = 0; Index < 10; ++Index) {
        fooVector.push_back( new Foo);
    }
    for (int i = 0; i < fooVector.size(); i++) {
        cout << (fooVector[i])->i << endl;
    }
    fooVector.clear();
    cout << "fooVector.size:"<< fooVector.size() << endl;
    return 0;
}
```

**现象&后果**

程序运行正常，但用内存检查工具查看时，发现有内存泄露发生。

**Bug分析**

代码中使用一个 vector 来存放对象指针，每 new —个 Foo 对象即将指向该对象的指针存入该 vector。程序结束时，打算通过 clear 方法清除所有元素及其占用的内存。问题就发生在这里，因为 STL 容器中存放的指针所指向的对象并不会随 clear 的清除而自动释放。

STL 容器可以存放对象，也可以存放指向对象的指针。如果容器存储的是对象，在容器析构的时候会自动清理这些对象，不需要人工干预。但如果容器里存储的是指针，则需要程序员自己手动释放指针所指向的对象。例如，一个vector 中存放的是 string 对象(非string对象指针), clear 方法在清除每个元素时，会自动调用 string 对象的析构函数释放对象。但是，如果 vector 存储的是对象的指针，像上面代码中那样，当清除 vector 中的元素时，只会调用指针的析构函数，而指针的析构函数什么也不做，这时就需要程序员手动删除指针所指向的对象了。上面代码中调用 vector 的 clear 方法并没有 delete 所有 new 生成的对象，而造成内存泄露。

所以当 STL 容器里存放指针时，释放资源的时候必须首先逐个释放掉指针所指向的资源，然后才能删除容器，否则会造成资源泄露。

**正确代码**

```cpp
// 在清除 vector 元素前，先手动删除对象指针所指向的对象。
void clearVectorContents(std:vector<Foo*> &a)
{
    for ( int i = 0; i < a.size); i++ ){
        delete a[i];
    }
}

int main()
{
    vector<Foo*> fooVector;
    for( int Index = 0; Index < 10; ++Index) {
        fooVector.push_back( new Foo);
    }
    for (int i = 0; i < fooVector.size(); i++) {
        cout << (fooVector[i])->i << endl;
    }
    clearVectorContents(fooVector);
    fooVector.clear();
    cout << "fooVector.size:"<< fooVector.size() << endl;
    return 0;
}
```

**编程建议**
使用STL时，需要注意:

1. STL容器是以复制的方式工作的。当你把一个元素放入容器中，在容器中存放的实际上是这个元素的一个副本，副本所占的内存是 STL 容器自己分配的。当删除这个元素时，STL 会自己调用该元素的析构函数回收这些内存。
2. 如果把指针放到容器中，删除元素的时候容器只负责回收指针本身所占的内存，但不会回收指针所指向的内容。



### 5.12 静态成员类内初始化

**代码示例**

```cpp
class Foo{
private:
	static const int MAX = 64;
	static const char flag = 'T';
	static const string msg = "Hello";
};
```

**现象&后果**

程序编译错误，提示在类内初始化静态成员 msg 是无效操作。

**Bug分析**

程序的目的是想定义若干个私有常量，其中包括一个字符串常量 msg，但在编译时提示，在类内初始化静态成员msg 是无效操作。编译失败的原因是，C++ 标准规定，在类的定义体内，只可以声明 static 成员变量，但不能初始化。**static 成员变量初始化必须在类定义体外进行。但这个规定有一个例外，允许整型 const static 可以在类的定义体中定义并初始化。**另外，由于字符型其实就是整型(就是它的ASCIl码值)，所以，字符型也可以在类定义体内初始化。

初始化一个非整型的 const 数据成员时，需要在类定义体外进行，而且前面不能加 static，以免与一般静态变量或对象相混淆，也不需要加访问权限控制符 private、public 等。另外，需在初始化时使用作用域运算符 “::” 来明它所属的类。具体格式如下:
<数据类型><类名>::<静态数据成员名>=<值>。

**正确代码**

```cpp
class Foo{
private:
	static const int MAX = 64;
	static const char flag = 'T";
	static const string msg;
};

const string Foo:msg = "Hello";
```



### 5.13 union作为类的成员时需要构造函数

**代码示例**

```cpp
class ExampleClass
{
    enum StoreType { Long, Const_CharP };
    union ExampleUnion
    {
        const char* ch_;
        long l_;
    }data;
    StoreType stype_;
public:
    ExampleClass(const char* ch) : data_(ch), stype_(Const_CharP){}
    ExampleClass(long l) : data_(l),stype_(Long){}
};

int main (void)
{
    ExampleClass ex1("hello world");
    ExampleClass ex2(12345);
    return 0;
}
```

**现象&后果**

程序编译错误，错误提示信息如下:

error: no matching function for call to'ExampleClass:.ExampleUnion::ExampleUnion(const char*&)
error: no matching function for call to'ExampleClass:ExampleUnion::ExampleUnion(long int&)

**Bug分析**

关键字union是一种特殊形式的数据类型。在union 中，所有的成员共用同一片内存，并且同一时间只能储存其中一个成员变量的值。union 的大小是它最大的那一个成员类型的大小。在 C++ 中，union 可以有构造/析构函数，也可以包含访问标识符，但不能包含虚函数或静态成员变量/方法。

上述代码在编译时，编译器创建 ExampleClass 类对象需要调用 ExampleClass 的构造函数，ExampleClass 的构造函数会调用其成员的构造函数，因此，构造函数 ExampleClass 要去调用成员 union 的构造函数，由于 union 没有对应的构造函数，导致编译错误。

**正确代码**

```cpp
    union ExampleUnion
    {
        ExampleUnion(const char* ch) : ch_(ch) {}
        ExampleUnion(long l) : l_(l) {}
        const char* ch_;
        long l_;
    }data;
```

**编程建议**
使用 union 可以节省内存空间，但是也有一定的风险：譬如通过一个不恰当的数据成员获取当前对象的值。为了防止这样的错误，建议使用一个额外的变量或枚举类型来记录当前存储在 union 中的值的类型。在处理作为类成员的 union 对象时，建议为所有 union 数据类型提供一组访问函数。



### 5.14 成员函数尾部缺失const标注

**代码示例**

```cpp
#include <time.h>
using namespace std ;
class Example{
public:
    void setData(int32_t data)
    {
        _data = data;
    }
    int32_t getData()
    {
        return _data;
    }
    private:
    int32_t _data;
};

int main()
{
    Example e;
    e.setData(10);
    const Example b = e;
    cout << e.getData() << endl;
    cout << b.getData() << endl;
}
```

**现象&后果**

程序编译错误，错误提示信息如下:
error:passing 'const Example' as 'this’ argument of 'int32_t Example::getData()’ discards qualifiers

**Bug分析**

一个类的 const 对象只能使用该类的 const 方法，而上述代码中的类 Example 的 getData 方法不是 const 类型，所以，const 对象 b 使用 getDate 方法时编译会报错。

**正确代码**

```cpp
class Example{
public:
    void setData(int32_t data)
    {
        _data = data;
    }
    int32_t getData() const
    {
        return _data;
    }
    private:
    int32_t _data;
};
```

**编程建议**
建议将所有不会修改对象数据成员的成员函数都声明为 const 类型。



### 5.15 使用memset初始化class

**代码示例**

```cpp
class Base{
protected:
    char *m_pcName;
public:
    virtual void Draw() {}
    char* Name() { return m_pcName; }
};

class Sub: public Base{
    void Draw() { printf("drawsomething\n"); }
};

int main(int argc, char **argv) {
    Base *obj = new Sub;
    memset((void *)obj, 0, sizeof(Sub));
    obj->Name();
    obj->Draw();
    return 0;
}
```

**现象&后果**

程序运行时出现段错误 ( Segmentationfault )。

**Bug分析**

首先介绍 C++ 中虚函数赖以生存的底层机制: vptr + vtable:

1. 编译器在后台为每个包含虚函数的类产生一个静态函数指针数组（虚函数表)，在这个类或者它的基类中定义的每一个虚函数都有一个相应的函数指针。
2. 每个包含虚函数的类的每一个实例包含一个不可见的数据成员 vptr (虚函数指针)，这个指针被构造函数自动初始化，指向类的 vtbl (虚函数表)。
3. 当客户调用虚函数的时候，编译器产生代码反指向到 vptr，索引到 vtbl 中，然后在指定的位置上找到函数指针，并发出调用。

在上面例子中，程序执行到 Base *obj = new Sub 时，虚函数指针已经自动初始化了，再执行 memset((void *)obj, 0, sizeof(Sub)) 时，memset 又将初始化好的指针清 0 了，因此，导致程序调用虚函数 Draw 时出现段错误。解决这个问题，只需将上面的 memset 语句去除就可以了。

**正确代码**

```cpp
int main(int argc, char **argv) {
    Base *obj = new Sub;
    obj->Name();
    obj->Draw();
    return 0;
}
```

**编程建议**
在 C 语言中，用 memset 函数去初始化一个结构或变量是非常常见的。在 C++ 中对结构或变量进行初始化也可以有类似的操作。但不建议使用 memset 对一个类的对象进行初始化。这是一种危险的操作，在某些情况下会导致程序 crash。不管一个类中是否含有虚函数，都不要使用这种方式初始化对象，养成良好的编程习惯。对对象成员的初始化操作可以放在构造函数或 init 等特定函数中。



### 5.16 dynamic_cast转换失败返回NULL

**代码示例**

```cpp
class Father{
public:
    int data;
    virtual ~Father() {};
    Father(){
        data = 0;
    }
    int get() {
        cout<< "Father.data:" << data << endl;
        return data;
    }
    void put(int value) {data = value;}
};

class Child : public Father {
    public:
    Child(){
        data = 5;
    }
    int get() {
        cout << "Child.data:"<< data <<endl;
        return data;
    }
    void putchild(int value){ data = value; }
};

int main(){
    Father father;
    Child *child = dynamic_cast<Child*>(&father);
    cout << "child:" << child->get() <<endl;
    return 0;
}
```

**现象&后果**

程序运行时出现段错误。

**Bug分析**

在 C++ 中，dynamic_cast 是一个运算符，主要用于类对象的指针和引用的类转换。其使用方法是: dynamic_cast < type-id > (exdivssion )，作用是把 exdivssion 转换成 type-id 类型的对象。其中 type-id 必须是类的指针、类的引用或者 void *。dynamic_cast 在执行类型转换时首先检查能否成功转换，如果能成功转换则转换；如果是指针转换失败，则返回0；如果是引用转换失败，则抛出 bad_cast 异常。

在上段代码的 main 函数中，利用 dynamic_cast 操作符把一个父类的指针强制转换成子类指针，然后调用子类的函数。在父类指针向子类指针转换时，由于父类的内存空间小于子类的，因此，父类向子类转换失败，dynamic_cast 返回 NULL，指针 child 的值为 NULL，所示访问 NULL 指针时出现段错误。

**正确代码**

```cpp
int main(){
    Father father;
    Child *child = dynamic_cast<Child*>(&father);
    if（child != nullptr)
    	cout << "child:" << child->get() <<endl;
    else
        cout << "child is NULL" << endl;
    return 0;
}
```

**编程建议**
使用 dynamic_cast 时必须注意以下几点。

1. type-id 和 exdivssion 必须保持类型一致。即，如果 type-id 是类指针类型，那么 exdivssion 也必须是一个指针；如果 type-id 是一个引用，那么 exdivssion 也必须是一个引用。
2. 父类中必须有虚函数。因为 dynamic_cast 在转换时会进行类型检查，此时需要运行时类型信息，这些信息存储在类的虚函数表中，而且只有定义了虚函数的类才有虚函数表，因此，要求父类中必须有虚函数。
3. dynamic_cast 转换指针失败会返回 NULL，如果是引用转换失败，则抛出 bad_cast 异常。因此，在 dynamic_cast 后要判断转换是否成功，如果成功才进行类函数调用，否则会出现段错误。



### 5.17 小结

在面向对象程序设计中，类和对象是其中最为重要的概念。它的知识点主要包括：构造函数、析构函数、继承、重载、多态等。这部分知识点较为复杂，因此，使用过程中要清晰地理解每个概念，灵活使用，避免由于概念不清，使用不当而导致问题出现。