## 第 1 章  基础问题

### 1.1 运算符优先级引起的问题

**代码示例**

```cpp
// To get 2*n+1
int func(int n)
{
    return n << 1 + 1;
}
```

**现象&后果**
		上述代码中的函数 func 本意是期望计算 2\*n+1，但程序实际运行结果是 4\*n。
**Bug分析**
		这段代码使用左移1位来代替乘以2的运算，是很好的方法，但是编程者弄错了运算符“<<”和“+”的优先级。C/C++语言规定运算符“+”的优先级高于运算符“< <”，因此，上述语句 “return n<<1+1” 等同于 “return n<<(1+1)”，所以，会先进行加法运算，再进行左移运算，得到结果4*n。
修正的方法是在表达式中添加必要的括号。

**正确代码**

```cpp
// To get 2*n+1
int func(int n)
{
    return (n << 1) + 1;
}
```



### 1.2 不加括号的宏定义引起的错误

**代码示例**

```cpp
#define PERIMETER(X,Y) 2*X+2*Y
```

**正确代码**

```cpp
#define PERIMETER(X,Y) (2*(X)+2*(Y))
```

**编程建议**
		由于宏替换可能会带来不可预期的结果，因此，使用宏时要非常谨慎。在C++中尽可能少使用宏，改用其他方式来代替。下面是几种常见的替代场景：程序中频繁被调用的代码段或者函数，期望使用宏替换来节省执行时间的，可以用内联函数代替；期望使用宏来存储常量的，可以用const变量代替；期望使用宏来“缩短”长变量名的，可以用引用来代替。



### 1.3 污染环境的宏定义

**代码示例**

在文件 a.cpp 中：

```cpp
#define map __gnu_cxx::hsah_map

map<long, long> myhashmap;
```

在文件 b.cpp 中：

```cpp
#include <map>
#include "a.cpp"

map<long, long> mymap;
```

**现象后果**

上述代码假设由两个人所写。a.cpp为程序员A所写，为了书写方便，A将库函数__gnu_cxx::hash_map宏定义为map。b.cpp为程序员B所写，B在b.cpp中包含了库map，同时在其后又包含了a.cpp。这最终导致B使用的map并非其预期的系统库map中的定义，而是\_\_gnu_cxx::hash_map。

**Bug分析**
由于宏替换是在预编译阶段执行的，所以在b.cpp 中，代码行 `map<long,long> mymap` 在预编译阶段会被宏替换为`__gnu_cxx::hash_map<long,long> mymap` ，虽然b.cpp中包含了 `#include\<map>`，在编译阶段编译器只会编译宏替换之后的代码，程序员B想要的map在预编译之后，在代码中已经找不到了。

这段代码虽然编译可以通过，也可以正常运行，但是用错了map和hash_map可能会引发不可预期的后果(如性能差别、功能扩展的区别)，埋下了程序稳定性差的隐患。

**正确代码**
修改文件a.cpp中的宏名字为hmap:

```cpp
#define hmap __gnu_cxx::hash_map
hmap<long, long> myhashmap;
```

**编程建议**
给宏定义命名时，要避免宏名称与系统库的定义同名。



### 1.4 多语句宏定义使用错误

**代码示例**

```cpp
#define EXIT(info) std:cerr << info << std::endl; exit(1)

int main()
{
	int data = 0;
	if(data < 0)
		EXIT("data is a negative number!");
    std:cerr << "data is a non-negativenumber." << std:endl;
}
```

**现象&后果**
这段代码定义了一个 EXIT 宏，当 data 为负数时，打印 “data is a negative number” 信息然后程序退出；当 data大于等于 0 时，打印 “non-negative”，然后程序结束。但是，实际运行结果是，当 data 为非负时，程序退出但没有打印 “data is a non-negativenumber”。

**Bug分析**
上述代码中的 if 语句，在 EXIT 宏展开后如下：

```cpp
if(data < 0)
	std::cerr << "data is a negative number!" << std:endl; exit(1);
```

正确地缩进以后，代码变成：

```cpp
if(data < 0)
	std::cerr << "data is a negative number!" << std:endl; 
exit(1);
```

显然 exit 语句不在 if 分支语句块中，所以，不管 data 的值是否为负数，exit 语句都会被执行。这和原意不符。
就上述问题而言，一种简单的解决办法是用大括号将宏定义的内容括起来：

```cpp
#define EXIT(info) { std:cerr << info << std::endl; exit(1); }
```

这种方法可以解决上述代码中的问题，但是在如下场景中依然有问题:

```cpp
void fuction(int data)
{
	if(data < 0)
		EXIT("data is a negative number!");
	else							// 编译出错
		cout << data << endl;
}
```

在宏替换之后变成:

```cpp
void fuction(int data)
{
	if(data < 0)
	{ 
        std:cerr << info << std::endl; 
        exit(1);  
    };
	else
		cout << data << endl;
}
```

这时多余的分号会出现语法错误。

所以推荐的另外一种修正做法是使用内联函数来替换宏定义，具体见下面的正确代码。

**正确代码**

```cpp
inline void EXIT(const char info[])
{
    std::cerr << info << std::endl;
    exit(1);
}

int main()
{
	int data = 0;
	if(data < 0)
		EXIT("data is a negative number!");
    std:cerr << "data is a non-negativenumber." << std:endl;
}
```



### 1.5 char转为int时高位符号扩展的问题

**代码示例**

```cpp
int main()
{
    char a = 0x9A;
    int util;
    util = (int)a;
    if( util > 0 )
        printf ("positive\n");
    else
        printf ("negative\n");
}
```

**现象&后果**
上述代码期望最后输 "positive"，但实际输出结果为 “negative”。

**Bug分析**
上述代码中, char 变重 a 的值为 0x9A，这个值有迷惑性。0x9A 转换为十进制为 154，所以，在把 a 强制转换为int 类型的变量 util 之后以为还是154 ，所以，期望输出 “positive” 。但实际上 0x9A 的二进制大小为 10011010，在强制转换为 int 时，因为 int 是是有符号的，需要对 10011010 进行符号扩展，也就是用其最高位 1 来扩充其他 3 个高字节，变成 11111111 11111111 11111111 10011010 (假设 int 是4个子节)，而这个是负数 -102 的二进制补码表示。所以，在判断 util 是否小于 0 时就会输出 “negative”。

从另外一个角度来说，变量 a 的类型为 char ,一般系统中 char 为有符号的，0x9A 解析为有符号的 char 时，其值实际上也为 -102。所以，0x9A 在强制变换前后是保持一致的。

但如果期望 0x9A 为正数，实际上需要先把 a 强制转换为 unsigned char。这样 0x9A 才会被解析为 154。

**正确代码**

```cpp
int main()
{
    char a = 0x9A;
    int util;
    util = (int)(unsigned char)a;
    if( util > 0 )
        printf ("positive\n");
    else
        printf ("negative\n");
}
```



### 1.6 int转为char时的数据损失

**代码示例**

```cpp
int main()
{
    char c;
    while ((c = getchar())!= EOF)
    {
        putchar(c);
    }
    return O;
}
```

**现象&后果**
各种系统都有自己默认的 char 类型，可能是 unsigned char，也可能是 signed char。假如当前系统默认的 char类型是 unsigned char，上述代码运行时会出现死循环。

**Bug分析**

在默认的 char 类型是 unsigned char 的系统中(可以通过g++编译时加参数 -funsigned-char 来模拟)，上述代码中, getchar() 返回一个 int 型，将被强制转换为 unsigned char 赋给 c，这样当 getchar 返回 EOF (-1）时，转换成 unsigned char 后的 ascii 值是 255。然后，系统在比较 c (unsigned char) 和 EOF 时，会将它们均转换为unsigned int 来比较，对前者是 (unsigned int)255，对后者是 (unsigned int)-1=232。虽然它们都表示 -1，但 8位的 -1和 32 位的 -1之间的差距却很大，永远不会相等，因而会造成死循环。

修正方法是去除 int 转为 char 的强制转换。

**正确代码**

```cpp
int main()
{
    int c;
    while ((c = getchar())!= EOF)
    {
        putchar(c);
    }
    return O;
}
```

**编程建议**
在编程过程中，对于变量的强制转换，需要注意类型的截断和扩展，特别是 char、unsigned char、unsigned int、int、 short 等类型在赋值时的隐式转换。



### 1.7 非法的数组下标

**编程建议**
C/C++ 语言中数组下标越界，编译器是不会检查出错误的，但是实际上后果会很严重，可能会导致程序崩溃等。当使用变量作为数组下标访问数组元素时，检查数组下标值的合理性是一个良好的编程习惯，可以避免数组越界的错误发生。



### 1.8 有符号int与无符号int比较的后果

**代码示例**

```cpp
int array[] = {23,24,12,204} ;
#define TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))

int main(void)
{
	int d = -1;
	if(d <= TOTAL_ELEMENTS)
        printf("TRUE\n");
	else
		printf("FALSE\n");
}
```

**现象&后果**

程序运行结果打印的是 FALSE 而不是 TRUE。

**Bug分析**

由于 sizeof() 的返回类型是无符号整型，因此，上述代码中 TOTAL_ELEMENTS 的值是 unsigned int 类型。if 语句在比较 signed int 型变量 d 和 TOTAL_ELEMENTS 宏返回的 unsigned int 型值的时候，signed int 型变量被转换为 unsigned int 型变量。-1 转换成 unsigned int 的结果是一个非常巨大的正整数(在32位操作系统上会转换成2^32-1)，导致 if 判断为假。

解决的办法是将宏 TOTAL_ELEMENTS 返回的结果强制转换为 int 型。

**正确代码**

```cpp
int array[] = {23,24,12,204} ;
#define TOTAL_ELEMENTS (int)(sizeof(array)/sizeof(array[0]))

int main(void)
{
	int d = -1;
	if(d <= TOTAL_ELEMENTS)
        printf("TRUE\n");
	else
		printf("FALSE\n");
}
```



### 1.9 有符号的困惑

**代码示例**

```cpp
struct data
{
	int flag: 1;
	int other: 31;
};

int status()
{
	return 1;
}

int main()
{
	struct data test;
    test.flag = status();
    if (test.flag == 1)
	{
		printf("test.flag=1 ,it's true !\n");
	}
	else
		printf( "test.flag != 1,it's false !!\n");
    return 0;
}
```

**现象&后果**

无论函数 status 的返回值是 1 还是其他值，都无法运行到 if 分支里面。

**Bug分析**

这段代码在结构体中定义了一个 int 型的位域变量，而用一个 bit 来表示 int 时，这一位是用来表示符号位的，带符号的一个 bit 的位域变量的取值范围是 0 或 -1 (无符号的一个 bit 的位域变量的取值范围是 0 或 1)。stauts() 的返回值 1 赋给 flag 时会出现溢出，flag 值变为 -1，所以 status 无论返回什么值给 flag，都不会是 1，这样就无法运行到 if 语句分支。
解决的办法是将包含标志位的变量设置为无符号型: unsigned int flag:1。

**正确代码**

```cpp
struct data
{
	unsigned int flag: 1;
	int other: 31;
};

int status()
{
	return 1;
}

int main()
{
	struct data test;
    test.flag = status();
    if (test.flag == 1)
	{
		printf("test.flag=1 ,it's true !\n");
	}
	else
		printf( "test.flag != 1,it's false !!\n");
    return 0;
}
```



### 1.10 整除的精度问题

**代码示例**

```cpp
int main()
{
    float result;
    result = 1 / 6;
    printf("result = %f\n", result);
}
```

**现象&后果**

代码计算出来 result 的结果是 0，不符合预期。

**Bug分析**

由于 1 和 6 都是整型常量，两个整型常量的运算结果依然是整型，因此，1/6 的结果为 0，不会保留小数部分。
如果希望保留小数部分，至少需要把一个数写成小数。

**正确代码**

```cpp
int main()
{
    float result;
    result = 1.0 / 6;
    printf("result = %f\n", result);
}
```

**编程建议**
关于 C 语言的隐式类型转换，总结有以下两点。

1. 赋值时，一律是右边值转换为左边类型，但是右边是表达式时，会先进行运算，然后才对运算的结果进行数据类型转换。
2. 当不同类型的变量进行计算时，遵循由低级向高级转换的规则，例如，char 型会转换为整型，short 型转换为int 型, float 型会转换为 double 型。



### 1.11 浮点数比较的精度问题

在计算机中，浮点数表示精度的位数有限，因此，不能准确地表示一个小数 (IEEE 754规定的单精度 float 数据类型的表示精度为 7 位有效数字，双精度 double 为 16 位有效数字)，所以，在代码中对浮点数据类型进行比较时不建议使用 \==、<=、 >=、!= 等比较运算符。例如，在计算中作如下比较：if (result== expect_result)，这个结果几乎是永远不可能为真的。即使某一次比较结果为真，那也是偶然的，因为，这个比较结果是不稳定的：数据、编译器的微小改变都可能使程序产生不同的结果。

浮点数进行比较时，一般比较它们之间的差值在一定范围之内。



### 1.12 最小负整数取相反数溢出

**代码示例**

```cpp
int main()
{
	int minInt = 0xffffffff;
    if (minInt < 0)
	{
		minlnt = -minlnt;
	}
	printf("%d\n", minlnt);
	return O;
}
```

**现象&后果**

程序目的是取相反数，但是取反后溢出，输出为1。

**Bug分析**

有符号的数据类型，均有正负数之分，如: int、float、double。int 表示范围不对称，例如，在 32 位机器上 , int 范围为 -2147483648~2147483647 ，如果对 -2147483648 取反得到的数将是溢出之后的 1。所以，在对int类型数据进行取反处理时，需要额外处理这种特殊情况。

**正确代码**

```cpp
int main()
{
	int minInt = 0xffffffff;
    
    if (minInt == 0xffffffff)
    {
        printf("%d\n", minlnt);
    }
    else if (minInt < 0)
	{
		minlnt = -minlnt;
	}
	printf("%d\n", minlnt);
	return 0;
}
```

**编程建议**
在对数据进行操作时，要考虑数据的取值范围，避免数据溢出造成程序稳定性差的问题。



### 1.13 临时变量溢出

**代码示例**

```cpp
long multiply(int m, int n)
{
	long score;
	score = m * n;
	return score;
}
```

**现象&后果**

当 m、n 都取较大的值时，如 1 亿(在 int 范围之内的较大值)，导致程序运行后处理结果不正确。

**Bug分析**

在 64 位操作系统下，int 型通常占4个字节，long 型通常占 8 个字节，两个 int 型变量相乘的值范围是 long 型变量的值范围。上述代码中,`score = m * n` 这行代码在执行时，m 和 n 相乘的结果会先存储在一个临时的 int 变量中，然后再赋值给 long 变量 score，这个临时变量是很容易溢出的。所以，需要在表达式运算前先对 m 和 n 做数据类型转换。

**正确代码**

```cpp
long multiply(int m, int n)
{
	long score;
	score = static_cast<long>(m) * static_cast<long>(n);
	return score;
}
```

**编程建议**
对隐式的类型转换，一般来说向上是安全的，向下会出现数据截断丢失，导致数据错误。

事实上，上述正确代码只在 long 型字节数是 int 型字节数两倍的情况下才是正确的，如果在某些平台下, long 型和 int 型字节数一样的话(如32位操作系统 int 型和 long 型通常都占 4 个字节)，仍然需要注意两个 int 型相乘结果溢出的问题。



### 1.14 size_t导致的死循环

**代码示例**

```cpp
int main(void)
{
	size_t size = sizeof(int);
	while( --size >= 0 )
	{
		cout<< "size = " << size << endl;
	}
	return 0;
}
```

**现象&后果**

while 条件永远为真，程序进入死循环。

**Bug分析**

size_t 是 sizeof 操作符返回的结果类型，size_t 在32位系统中是 unsigned int，在 64 位系统中是 unsigned long int。上述代码中，每执行一遍语句“while(--size>=0)” , size 就会减 1，当 size 的值等于 0 并再次作 --size 运算时，size 会因溢出再次等于它取值范围内的最大值，所以，size 的值恒大于等于0，while 条件一直为真。

**正确代码**

```cpp
int main(void)
{
	size_t size = sizeof(int);
	while( --size > 0 )
	{
		cout<< "size = " << size << endl;
	}
    if (size == 0)
		cout<< "size = " << size << endl;
	return 0;
}
```



### 1.15 误用short引起缓冲区溢出

**代码示例**

```cpp
#define MAX_BUF 256
#define OVER_SHORT 50000 //大于short最大值32767
void testCode(char *input)
{
    short len = strlen(input);
    char buf[MAX_BUF];
    cout<< "strlen(input) is:" << strlen(input) << endl;
    cout < < "len is :" < < len << endl;
    cout <<"MAX_BUF is:" << MAX_BUF << endl;
    if(len < MAX_BUF)
    {
        //do copy
        strcpy(buf, input);
    } else {
        cout << "overflow!" c< endl;
    }
}
int main)
{
    char *str = new char[OVER_SHORT];
    memset(str, 'a', OVER_SHORT);
    str[OVER_SHORT - 1] = "\0";
    testCode(str);
    return O;
}
```

**现象&后果**

程序运行时缓冲区溢出引起错误。

**Bug分析**

strlen (的返回值是 size_t 类型，size_t 在 32 位系统是 unsigned int 型，通常占 4 个字节，在 64 位系统是 unsigned long int 型，通常占 8 个字节，而 short 类型一般占两个字节 (short 的取值范围为 -2^{15} ~ 2^{15}-1)。一个 size_t 类型变量赋值给 short 类型时，如果 size_t 超过了 short 能表示的最大值时，将会引起溢出。上述代码中，执行 len =strlen(input) 语句时，由于 input 字符串长度(49999）超过了 short 的最大值，导致 len 溢出变成负数，从而导致 if 判断为 true，执行 strcpy(buf,input) 语句，而 buf 缓冲区长度小于 input 字符串长度，造成缓冲区溢出并引发错误。

正确的做法是将函数 TestCode 中的变量 len 的数据类型改为 size_t。

**正确代码**

```cpp
void testCode(char *input)
{
    size_t len = strlen(input);
    char buf[MAX_BUF];
    cout<< "strlen(input) is:" << strlen(input) << endl;
    cout < < "len is :" < < len << endl;
    cout <<"MAX_BUF is:" << MAX_BUF << endl;
    if(len < MAX_BUF)
    {
        //do copy
        strcpy(buf, input);
    } else {
        cout << "overflow!" c< endl;
    }
}
```



### 1.16 区分continue和return

return 用来返回某个值并退出程序。

在循环中，continue 是结束本轮循环，执行下一次循环。



### 1.17 指针常量和常量指针的区别

指针常量：指针本身是常量。它指向的地址是不可改变的，但地址里的内容可以通过指针改变。

常量指针：指向常量的指针，它指向的内容不能被改变，不能通过指针来修改它指向的内容，但是指针自身不是常量，它自身的值可以改变。



### 1.18 字符数组和指针不总是等价的

**代码示例**

文件sub.cpp中:

```cpp
char str[]= "Hello World!\n";
```

main函数所在文件中:

```cpp
#include <iostream>
extern char *str;
int main()
{
    std::cout << str << std:endl;
    return 0;
}
```

**现象&后果**

g++编译报错。报错信息如下:

```bash
error: conflicting declaration 'char* str'
error: 'str' has a previous declaration as'char str [14]'
```

**Bug分析**

关键字 extern 可以置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量或函数时在其他模块中寻找其定义。编译上述代码时，编译器会去 sub.cpp 中查找 *str 变量，但是，sub.cpp 中没有定义 str 这个指针变量，只是定义了 str[] 数组。因此查找失败，导致编译器报错。所以，char 数组和 char 指针在很多时候可以相互替换，但这种在不同文件中用 extern 引用时，它们仍然是不同的。

**正确代码**

```cpp
extern char str[];
int main()
{
    printf(" in main.c, str:%s\n", str);
    return 0;
}
```



### 1.19 结构体成员变量初始化的隐患

**代码示例**

```cpp
struct rectangle
{
    int lenth;
    int width;
};

int main()
{
    struct rectangle rect1 = {4,2};
    return 0;
}
```

**现象&后果**

这段代码虽然编译和运行时不会有任何问题，但是，一旦结构体的成员变量顺序发生了变化，就可能导致错误。

**Bug分析**

这段程序对结构体的内存布局作了假设。一旦调整了结构体成员变量的顺序，调用方(示例中的 main 函数）即使不修改代码，编译时也不会有错误提示，但是程序的逻辑却发生了变化，这往往会导致错误发生。尤其是当这个结构体是第三方提供的时候，这种调整往往会被调用方的程序员所忽略。

**正确代码**

```cpp
int main()
{
	struct rectangle rect1 = { rect1.lenth = 4, rect1.width = 2 };
	return 0;
}
```

**编程建议**
对结构体进行赋值时，建议具体到结构体的成员变量名。



### 1.20 返回值非 void 的函数没有返回值

**编程建议**
非 void 类型的函数，建议在每个分支都要有明确的返回值。



### 1.21 cin >> 和 getline 混用导致的奇怪问题

**代码示例**

```cpp
int main()
{
    int zipcode;
    string address;
    
    cout << "Please Input Zipcode:"<<endl;
    stdcin > > zipcode;
    
    cout << "Please Input Address:"<<endl;
    getline(cin, address);
    
    cout << "Zipcode:" << zipcode <<endl;
    cout << "Address:"<< address <<endl;
    return 0;
}
```

**现象&后果**

程序的功能是用操作符 “>>” 和 getline 分别从命令行读取两个输入：一个整型的 zipcode 和一个字符串形式的address。但运行时发现，程序在用户输入 zipcode 后不会等待用户输入 address，即用 getline 输入 address 代码会被自动跳过，用户没有机会输入地址字符串。

**Bug分析**

cin 是 C++ 标准输入流 istream 类型对象，代表标准输入设备，相当于 C 语言里的 stdin。在程序中包含 iostream 头文件即可使用 cin 对象。istream 类重载了抽取操作符 “>>”，能够读取 C+＋中的各种基础数据类型。抽取操作符 “>>” 根据后面变量的类型读取数据，从非空白符号开始，遇到 Enter、Space、Tab 键时结束。std:getline 函数则用于从 istream 中读取一行数据，当遇到换行符 “\n” 时结束返回。

这个问题的根源在于抽取操作符 “>>”。当用户在命令行输入zipcode 值时， cin>> 读取到一个连续的数字（无空格) 后立即停止，把用户按下回车键时，换行符“ \n” 留在了输入流里。**cin 不会主动删除输入流里的换行符。这样，“\n” 被后续的 getline 读到，因为 getline 遇到换行符结束，所以，getline 不会等待用户在终端输入数据，而是立即结束返回。**因而造成上面所说的奇怪现象，这种情况下 address 得到一个空的赋值。一个简单的解决办法是在每—个 cin>> 后加一个 cin.ignore()，用于清除留在输入流里的换行符。

**正确代码**

```cpp
int main()
{
    int zipcode;
    string address;
    
    cout << "Please Input Zipcode:"<<endl;
    stdcin > > zipcode;
    cin.ignore()；
    
    cout << "Please Input Address:"<<endl;
    getline(cin, address);
    
    cout << "Zipcode:" << zipcode <<endl;
    cout << "Address:"<< address <<endl;
    return 0;
}
```

**编程建议**
上面的简单方法虽然能解决问题，但建议最好不要在同一段代码中混用抽取操作符 “>>” 和 std::getline()。因为如果混用，需要特别注意 “>>” 是否在输入流中留下了换行符，如果留下了换行符或者其他字符或者标志，往往会造成意想不到的麻烦。一种更好的办法是使用 getline 一次读取一行用户输入，将用户输入视为字符串，然后再从该字符串中解析自己需要的数据。下面的代码提供了这样的一种方案。

```cpp
int main 0
{
    int zipcode;
    string address;
    string input = "";
    while (true)
    {
        cout << "Please Input Zipcode:" <<endl;
        getline(cin, input);
        stringstream myStream(input);
        if ( myStream >> zipcode )
            break;
        else
            cout << "lnvalid number, please try again" << endl;
    }
    cout<< "Please Input Address:"<<endl;
    getline(cin, address);
    cout << "Zipcode:" << zipcode <<endl;
    cout << "Address:" << address <<endl;
    return 0;
}
```



### 1.22 小结

通过以上这些基本问题的分析，我们可以了解 C/C++ 语言最基本的一些特性，很多复杂问题在经过分解之后其根源也可以归结为这些基本问题。本章列出的 20 的个例子无法覆盖基础知识的方方面面，期望读者从中得到启发，做到举一反三，进而可以更好地分析复杂问题。