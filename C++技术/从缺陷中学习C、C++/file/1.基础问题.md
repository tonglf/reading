## 第 1 章  基础问题

### 1.1 运算符优先级引起的问题

**代码示例**

```cpp
// To get 2*n+1
int func(int n)
{
    return n << 1 + 1;
}
```

**现象&后果**
		上述代码中的函数 func 本意是期望计算 2\*n+1，但程序实际运行结果是 4\*n。
**Bug分析**
		这段代码使用左移1位来代替乘以2的运算，是很好的方法，但是编程者弄错了运算符“<<”和“+”的优先级。C/C++语言规定运算符“+”的优先级高于运算符“< <”，因此，上述语句 “return n<<1+1” 等同于 “return n<<(1+1)”，所以，会先进行加法运算，再进行左移运算，得到结果4*n。
修正的方法是在表达式中添加必要的括号。

**正确代码**

```cpp
// To get 2*n+1
int func(int n)
{
    return (n << 1) + 1;
}
```



### 1.2 不加括号的宏定义引起的错误

**代码示例**

```cpp
#define PERIMETER(X,Y) 2*X+2*Y
```

**正确代码**

```cpp
#define PERIMETER(X,Y) (2*(X)+2*(Y))
```

**编程建议**
		由于宏替换可能会带来不可预期的结果，因此，使用宏时要非常谨慎。在C++中尽可能少使用宏，改用其他方式来代替。下面是几种常见的替代场景：程序中频繁被调用的代码段或者函数，期望使用宏替换来节省执行时间的，可以用内联函数代替；期望使用宏来存储常量的，可以用const变量代替；期望使用宏来“缩短”长变量名的，可以用引用来代替。



### 1.3 污染环境的宏定义



### 1.4 多语句宏定义使用错误



### 1.5 char转为int时高位符号扩展的问题



### 1.6 int转为char时的数据损失



### 1.7 非法的数组下标



### 1.8 有符号int与无符号int比较的后果



### 1.9 有符号的困惑



### 1.10 整除的精度问题



### 1.11 浮点数比较的精度问题



### 1.12 最小负整数取相反数溢出



### 1.13 临时变量溢出



### 1.14 size_t导致的死循环



### 1.15 误用short引起缓冲区溢出



### 1.16 区分continue和return



### 1.17 指针常量和常量指针的区别



### 1.18 字符数组和指针不总是等价的



### 1.19 结构体成员变量初始化的隐患



### 1.20 返回值非void的函数没有返回值



### 1.21 cin> >和getline混用导致的奇怪问题



### 1.22 小结