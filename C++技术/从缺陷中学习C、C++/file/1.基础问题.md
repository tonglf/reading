## 第 1 章  基础问题

### 1.1 运算符优先级引起的问题

**代码示例**

```cpp
// To get 2*n+1
int func(int n)
{
    return n << 1 + 1;
}
```

**现象&后果**
		上述代码中的函数 func 本意是期望计算 2\*n+1，但程序实际运行结果是 4\*n。
**Bug分析**
		这段代码使用左移1位来代替乘以2的运算，是很好的方法，但是编程者弄错了运算符“<<”和“+”的优先级。C/C++语言规定运算符“+”的优先级高于运算符“< <”，因此，上述语句 “return n<<1+1” 等同于 “return n<<(1+1)”，所以，会先进行加法运算，再进行左移运算，得到结果4*n。
修正的方法是在表达式中添加必要的括号。

**正确代码**

```cpp
// To get 2*n+1
int func(int n)
{
    return (n << 1) + 1;
}
```



### 1.2 不加括号的宏定义引起的错误

**代码示例**

```cpp
#define PERIMETER(X,Y) 2*X+2*Y
```

**正确代码**

```cpp
#define PERIMETER(X,Y) (2*(X)+2*(Y))
```

**编程建议**
		由于宏替换可能会带来不可预期的结果，因此，使用宏时要非常谨慎。在C++中尽可能少使用宏，改用其他方式来代替。下面是几种常见的替代场景：程序中频繁被调用的代码段或者函数，期望使用宏替换来节省执行时间的，可以用内联函数代替；期望使用宏来存储常量的，可以用const变量代替；期望使用宏来“缩短”长变量名的，可以用引用来代替。



### 1.3 污染环境的宏定义

**代码示例**

在文件 a.cpp 中：

```cpp
#define map __gnu_cxx::hsah_map

map<long, long> myhashmap;
```

在文件 b.cpp 中：

```cpp
#include <map>
#include "a.cpp"

map<long, long> mymap;
```

**现象后果**

上述代码假设由两个人所写。a.cpp为程序员A所写，为了书写方便，A将库函数__gnu_cxx::hash_map宏定义为map。b.cpp为程序员B所写，B在b.cpp中包含了库map，同时在其后又包含了a.cpp。这最终导致B使用的map并非其预期的系统库map中的定义，而是\_\_gnu_cxx::hash_map。

**Bug分析**
由于宏替换是在预编译阶段执行的，所以在b.cpp 中，代码行 `map<long,long> mymap` 在预编译阶段会被宏替换为`__gnu_cxx::hash_map<long,long> mymap` ，虽然b.cpp中包含了 `#include\<map>`，在编译阶段编译器只会编译宏替换之后的代码，程序员B想要的map在预编译之后，在代码中已经找不到了。

这段代码虽然编译可以通过，也可以正常运行，但是用错了map和hash_map可能会引发不可预期的后果(如性能差别、功能扩展的区别)，埋下了程序稳定性差的隐患。

**正确代码**
修改文件a.cpp中的宏名字为hmap:

```cpp
#define hmap __gnu_cxx::hash_map
hmap<long, long> myhashmap;
```

**编程建议**
给宏定义命名时，要避免宏名称与系统库的定义同名。



### 1.4 多语句宏定义使用错误

**代码示例**

```cpp
#define EXIT(info) std:cerr << info << std::endl; exit(1)

int main()
{
	int data = 0;
	if(data < 0)
		EXIT("data is a negative number!");
    std:cerr << "data is a non-negativenumber." << std:endl;
}
```

**现象&后果**
这段代码定义了一个 EXIT 宏，当 data 为负数时，打印 “data is a negative number” 信息然后程序退出；当 data大于等于 0 时，打印 “non-negative”，然后程序结束。但是，实际运行结果是，当 data 为非负时，程序退出但没有打印 “data is a non-negativenumber”。

**Bug分析**
上述代码中的 if 语句，在 EXIT 宏展开后如下：

```cpp
if(data < 0)
	std::cerr << "data is a negative number!" << std:endl; exit(1);
```

正确地缩进以后，代码变成：

```cpp
if(data < 0)
	std::cerr << "data is a negative number!" << std:endl; 
exit(1);
```

显然 exit 语句不在 if 分支语句块中，所以，不管 data 的值是否为负数，exit 语句都会被执行。这和原意不符。
就上述问题而言，一种简单的解决办法是用大括号将宏定义的内容括起来：

```cpp
#define EXIT(info) { std:cerr << info << std::endl; exit(1); }
```

这种方法可以解决上述代码中的问题，但是在如下场景中依然有问题:

```cpp
void fuction(int data)
{
	if(data < 0)
		EXIT("data is a negative number!");
	else							// 编译出错
		cout << data << endl;
}
```

在宏替换之后变成:

```cpp
void fuction(int data)
{
	if(data < 0)
	{ 
        std:cerr << info << std::endl; 
        exit(1);  
    };
	else
		cout << data << endl;
}
```

这时多余的分号会出现语法错误。

所以推荐的另外一种修正做法是使用内联函数来替换宏定义，具体见下面的正确代码。

**正确代码**

```cpp
inline void EXIT(const char info[])
{
    std::cerr << info << std::endl;
    exit(1);
}

int main()
{
	int data = 0;
	if(data < 0)
		EXIT("data is a negative number!");
    std:cerr << "data is a non-negativenumber." << std:endl;
}
```



### 1.5 char转为int时高位符号扩展的问题

**代码示例**

```cpp
int main()
{
    char a = 0x9A;
    int util;
    util = (int)a;
    if( util > 0 )
        printf ("positive\n");
    else
        printf ("negative\n");
}
```

**现象&后果**
上述代码期望最后输 "positive"，但实际输出结果为 “negative”。

**Bug分析**
上述代码中, char 变重 a 的值为 0x9A，这个值有迷惑性。0x9A 转换为十进制为 154，所以，在把 a 强制转换为int 类型的变量 util 之后以为还是154 ，所以，期望输出 “positive” 。但实际上 0x9A 的二进制大小为 10011010，在强制转换为 int 时，因为 int 是是有符号的，需要对 10011010 进行符号扩展，也就是用其最高位 1 来扩充其他 3 个高字节，变成 11111111 11111111 11111111 10011010 (假设 int 是4个子节)，而这个是负数 -102 的二进制补码表示。所以，在判断 util 是否小于 0 时就会输出 “negative”。

从另外一个角度来说，变量 a 的类型为 char ,一般系统中 char 为有符号的，0x9A 解析为有符号的 char 时，其值实际上也为 -102。所以，0x9A 在强制变换前后是保持一致的。

但如果期望 0x9A 为正数，实际上需要先把 a 强制转换为 unsigned char。这样 0x9A 才会被解析为 154。

**正确代码**

```cpp
int main()
{
    char a = 0x9A;
    int util;
    util = (int)(unsigned char)a;
    if( util > 0 )
        printf ("positive\n");
    else
        printf ("negative\n");
}
```



### 1.6 int转为char时的数据损失

**代码示例**

```cpp
int main()
{
    char c;
    while ((c = getchar())!= EOF)
    {
        putchar(c);
    }
    return O;
}
```

**现象&后果**
各种系统都有自己默认的 char 类型，可能是 unsigned char，也可能是 signed char。假如当前系统默认的 char类型是 unsigned char，上述代码运行时会出现死循环。

**Bug分析**

在默认的 char 类型是 unsigned char 的系统中(可以通过g++编译时加参数 -funsigned-char 来模拟)，上述代码中, getchar() 返回一个 int 型，将被强制转换为 unsigned char 赋给 c，这样当 getchar 返回 EOF (-1）时，转换成 unsigned char 后的 ascii 值是 255。然后，系统在比较 c (unsigned char) 和 EOF 时，会将它们均转换为unsigned int 来比较，对前者是 (unsigned int)255，对后者是 (unsigned int)-1=232。虽然它们都表示 -1，但 8位的 -1和 32 位的 -1之间的差距却很大，永远不会相等，因而会造成死循环。

修正方法是去除 int 转为 char 的强制转换。

**正确代码**

```cpp
int main()
{
    int c;
    while ((c = getchar())!= EOF)
    {
        putchar(c);
    }
    return O;
}
```

**编程建议**
在编程过程中，对于变量的强制转换，需要注意类型的截断和扩展，特别是 char、unsigned char、unsigned int、int、 short 等类型在赋值时的隐式转换。



### 1.7 非法的数组下标

**编程建议**
C/C++ 语言中数组下标越界，编译器是不会检查出错误的，但是实际上后果会很严重，可能会导致程序崩溃等。当使用变量作为数组下标访问数组元素时，检查数组下标值的合理性是一个良好的编程习惯，可以避免数组越界的错误发生。



### 1.8 有符号int与无符号int比较的后果



### 1.9 有符号的困惑



### 1.10 整除的精度问题



### 1.11 浮点数比较的精度问题



### 1.12 最小负整数取相反数溢出



### 1.13 临时变量溢出



### 1.14 size_t导致的死循环



### 1.15 误用short引起缓冲区溢出



### 1.16 区分continue和return



### 1.17 指针常量和常量指针的区别



### 1.18 字符数组和指针不总是等价的



### 1.19 结构体成员变量初始化的隐患



### 1.20 返回值非void的函数没有返回值



### 1.21 cin> >和getline混用导致的奇怪问题



### 1.22 小结