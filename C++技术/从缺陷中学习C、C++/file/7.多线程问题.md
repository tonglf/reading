## 第 7 章  多线程问题

### 7.1 局部静态变量非线程安全

**代码示例**

```cpp
#define MAX_SIZE 1024 * 8

void* char2str(void* n) {
    int num = *(int*)n;
    static char buf[MAX_SIZE];
    for (int i = 0;i < MAX_SIZE - 1;i++) {
        buf[i] = num;
    }
    buf[MAX_SIZE - 1] = "\0";
    printf("%s\n\n\n ",buf);
}

int main() {
    pthread_t pid1,pid2;
    int cur = 'A';
    int cur2 = 'B';
    pthread_create(&pid1, NULL, char2str, &cur);
    pthread_create(&pid2, NULL, char2str, &cur2);
    pthread join(pid1, NULL);
    pthread join(pid2,NULL);
}
```

**现象&后果**

在上面代码中，两个线程调用同一个函数 char2str，该函数中有一个长度为 8KB 的局部静态变量 buf。其中一个线程将静态变量 buf 赋值为只包含字符 A 的字符串 “AAA...”，另外一个线程将 buf 赋值为只包含字符 B 的字符串 “BBB...”。程序运行时发现，第一个线程打印 buf 内容时输出里不仅包含应有的字符 A，也出现了字符 B，而第一个线程并未给 buf 赋值字符B。

**Bug分析**

线程安全是编写多线程程序时的一个概念。一段程序是线程安全的，是指该段程序在多个线程并发执行时仍能正常工作。为了保证线程安全，在多个线程访问共享数据时，需要保证在任意时刻只允许有一个线程访问。这里所说的访问主要是指有写操作。

在C/C++中，局部静态变量具有记忆性和生存周期的全局性特点。记忆性是指在两次函数调用期间，在第二次调用进入时，静态变量能保存第一次调用退出时的值。所谓生存周期的全局性，是指静态局部变量存储在静态存储区，在程序整个生存周期都不释放。普通的局部变量的存储空间分配在栈上，每次函数调用时，分配的内存地址都可能不一样，函数退出时，占用的空间会自动被释放。而静态变量具有全局唯一性的特点，每次调用时，都指向同
一块内存，所以上次访问保存的结果能被下一次访问看到。

上面函数 char2str 代码中，定义了一个静态局部变量 buf，该变量在每次函数被调用时都位于相同的内存地址。当两个线程同时访问该函数时，静态变量 buf 可能被两个线程同时修改。一个变量被两个线程同时修改时结果是不确定的，什么都可能发生。这里看到的现象是，第二个线程给 buf 赋值字符 B 的结果也被第一个线程看到了，所以第一个线程打印输出 buf 时既看到了字符 A 也看到了字符 B。函数 char2str 中的一个静态局部变量引起了线程安全问题。

**正确代码**

为了保证线程安全，在更改静态局部变量 buf 时，可以对其加锁，加锁保证同一时刻只有一个线程访问该静态变量。同时为了打印输出只看到自己的更改结果，也可以将打印输出语句放在锁定范围内。

```cpp
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void* char2str(void* n) {
    int num = *(int*)n;
    pthread_mutex_lock(&mutex);
    static char buf[MAX_SIZE];
    for (int i = 0;i < MAX_SIZE - 1;i++) {
        buf[i] = num;
    }
    buf[MAX_SIZE - 1] = "\0";
    printf("%s\n\n\n ",buf);
    pthread_mutex_unlock(&mutex);
}
```

**编程建议**
如果程序中存在静态变量，不管是静态全局变量还是静态局部变量，往往都存在线程安全问题，在多线程环境下需要特别注意。



### 7.2 string类append操作非线程安全

**代码示例**

```cpp
void* thread_a(void* ptr) {
    for(int i = O;i < 5;i++){
        ((std::string*)ptr)->append("apple");
    }
}

void* thread_b(void* ptr) {
    for(int i = O;i < 5;i++){
        ((std::string*)ptr)->append("orange");
    }
}

int main() {
    pthread_t pid1,pid2;
    string global_str, tmp;
    pthread_create(&pid1, NULL, thread_a, &global_str);
    pthread_create(&pid2, NULL, thread_b, &global_str);
    pthread_join(pid1, NULL);
    tmp = global_str;
    pthread_join(pid2, NULL);
    cout << tmp <<endl;
    cout << global_str << endl;
}
```

**现象&后果**

程序的目的是两个线程循环地向一个公共变量 global_str 中追加字符 “apple” 串和 "orange” 串，不在乎 apple 和orange 出现的顺序和多少。程序执行时有时会产生 coredump，并提示“ double free orcorruption” 错误。

**Bug分析**

C++ string 类的 append 函数和 reserve 函数实现如下:

```cpp

```

append操作的大概步骤是:

1. 先判断被复制字符串的容量是否足够容纳原有字符串加上被追加字符串。
2. 如果不够的话，调用reserve函数预留所需空间。函数reserve做的事情是，申请空间，将原字符串复制到新空间，再释放掉原来字符串所占内存。
3. 将被追加字符串复制到原字符串后面。因为append操作是非原子的，在多线程情况下容易出现问题，如下面两种情况:
    1. 线程1和线程2都进入了 reserve 函数中，线程1复制了原字符串到新空间，释放掉原字符串内存之时，线程2正在复制已经被线程1释放掉的原字符串，就会造成非法访问内存错误。
    2. 假定源字符串长度为 100 字节，线程1将给该字符串追加 100 字节新字符串，线程2将给该字符串追加200字节新字符串。为此，为了容纳源字符串和追加字符串，假定线程1预留了200字节(100+100)，线程2预留了300字节(100+200)。当线程1追加完字符串后，源字符串长度变为200字节，而此时线程2并不知情，而是将这个200字节的字符串当作源字符串，向它追加200字节，追加后实际字符串长度将变为400字节，但线程2只预留了300字节的空间，已经超过了实际申请内存空间的大小。所以，这种情况也会出现访问内存错误。

**正确代码**

对共享变量的append追加操作加上互斥锁，以保证线程安全。

```cpp
pthread_mutex_t mutex;

void* thread_a(void* ptr) {
	pthread_mutex_lock(&mutex);
    for(int i = 0;i < 5; i++){
        ((std::string*)ptr)->append("apple");
    }
	pthread_mutex_unlock(&mutex);
}

void* thread_b(void* ptr) {
	pthread_mutex_lock(&mutex);
    for(int i = 0;i < 5; i++){
        ((std::string*)ptr)->append("orange");
    }
	pthread_mutex_unlock(&mutex);
}
```



### 7.3 中途退出造成的线程阻塞

**代码示例**

```cpp

```

**现象&后果**



**Bug分析**



**正确代码**

```cpp

```

**编程建议**
在多线程编程中，要特别注意临界区内中途返回的情况。每当互斥锁锁定的临界区内有 return 发生时，都要确认这样的操作是否会造成问题。

### 7.4 结构体位域成员线程安全问题

**代码示例**

```cpp

```

**现象&后果**



**Bug分析**



**正确代码**

```cpp

```



### 7.5 多线程写文件引发内容被覆盖

**代码示例**

```cpp
void *write_start(void *args) {
	int i = O;
	char *pstr = (char *)args;
    for (i = 0; i < 100000; i++) {
        lseek(fd, 0L, SEEK_END);
        write(fd, pstr, len+1);
	}
}

int main() {
    int i = 0;
    char str[2][len+1];
    const int thread_count = 2;
    pthread_t tids[thread_count];
    fd = open("test.log", O_CREAT|O_RDWR, 0666);
    memset(str[0], '0',len);
    str[0][len] = '\n';
    pthread_create(&tids[0], NULL,write_start, &str[0]);
    memset(str[1],'1',len);
    str[1][len] = '\n';
    pthread_create(&tids[1], NULL,write_start, &str[1]);
    for(i = 0; i < thread_count; i++) {
        pthread join(tids[i], NULL);
    }
    printf("'\n>>Result: Use command >wc -l test.log < check.n");
    close(fd);
    return 0;
}
```

**现象&后果**

上面代码中启动两个线程调用write_start函数同时写一个日志文件，write_start函数每次写入10万行数据，所以两个线程一共应该写入20万行，但结果发现，最后日志文件总行数少于20万行，一些写入内容被丢掉了。

**Bug分析**



**正确代码**

```cpp
// 通过 fcntl 函数设置文件状态标志:
fd = open("test.log", O_CREAT|O_RDWR,0666);
fcntl(fd, F_SETFL,O_RDWR|O_APPEND);

// 或者直接在open时设置:
fd = open("test.log", O_RDWR|O_APPEND, 0666);
```

**编程建议**
除上面改变文件状态标志方法外，当然也可以通过给写日志代码段加互斥锁的方法来解决。



### 7.6 线程未join引起的内存泄露

**代码示例**

```cpp
void* thread_func(void* ptr) {
	pid_t pid;
	pthread_t tid;
	pid = getpid();
	tid = pthread_self();
	printf(" pid: %u tid: %u\n", (unsignedint)pid, (unsigned int)tid);
}

int main() {
	pthread_t pid[5];
	int rc;
	for (int i = 0;i < 5;i++) {
		if(rc = pthread_create(&pid[i],NULL,thread_func, NULL)) {
			return -1;
		}
	printf(" %ld threads created\n" , i+1);
	}
}
```

**现象&后果**

程序编译运行正常，当用内存泄漏检查工具valgrind检查时，报告说有内存泄露发生。

**Bug分析**

解决这个问题的一个方法就是在创建新线程后记得join该线程。

**正确代码**

```cpp
int main() {
	pthread_t pid[5];
	int rc;
	for (int i = 0;i < 5;i++) {
		if(rc = pthread_create(&pid[i],NULL,thread_func, NULL)) {
			return -1;
		}
	printf(" %ld threads created\n" , i+1);
	}
    for (int i = O;i < 5;i++) {
        pthread_join(pid[i], NULL);
    }
}                          
```



### 7.7 小结

使用多线程有很多益处。但多线程环境编程与单线程环境有很多不同，多个线程同时访问共享数据时可能因冲突产生不确定的结果，需要做线程同步管理。多个线程同步时，如果访问共享资源顺序不当，可能导致线程死锁。C/C++ 中的一些数据结构、函数或方法并非是线程安全的，当应用在多线程环境时需要特别注意。

总体来说，多线程编程往往是让程序员比较头痛的地方:陷阱多，线程执行顺序不确定，一旦发生问题，调试定位问题困难。所以，掌握必要的基础知识，编程前做好系统设计，防患于未然才是上策。