### 1.9.4 increment / decrement / dereference 操作符

increment / dereference 操作符在迭代器的实现上占有非常重要的地位，因为任何一个迭代器都必须实现出前进（ increment, operator++）和取值（ dereference, operator*）功能，前者还分为前置式 ( prefix ）和后置式 ( postfix ）两种，有非常规律的写法$^{[14]}$。有些迭代器具备双向移动功能，那么就必须再提供 decrement 操作符（也分前置式和后置式两种)。下面是一个范例:

```cpp
// file: 1config-operator-overloading.cpp 
// vc6[x] cb4[o] gcc[o]
// vc6的 friend机制搭配 C++标准链接库，有bug

// increment ++ 前进
// decrement -- 后退
// prefix 前置 与 postfix 后置
// dereference * 解引用
// reference & 取地址 引用

#include <iostream>
using namespace std;

class INT {
	friend ostream &operator<<(ostream &os, const INT &i);

public:
	INT(int i) : m_i(i) {};

	// 前置返回原对象，后置返回值（新创建）

	// prefix increment
	INT& operator++() {		// ++i
		++(this->m_i);
		return *this;
	}

	// postfix increment 需要占位符int
	const INT operator++(int) {		// i++
		INT temp = *this;
		++(*this); // 调用前置++
		return temp;
	}

	// prefix decrement
	INT& operator--() {		// --i
		--(this->m_i);
		return *this;
	}

	// postfix increment 需要占位符int
	const INT operator--(int) {		// i--
		INT temp = *this;
		--(*this); // 调用前置--
		return temp;
	}

	// dereference   
	// const后置修饰函数表示为常函数，不能修改成员变量
	// 但能修改mutable修饰的成员变量
	int& operator*() const {
		return (int &)m_i;
		//以上转换动作告诉编译器，你确实要将 const int转为 non-const lvalue. 
		// 如果没有这样明白地转型，有些编译器会给你警告，有些更严格的编译器会视为错误
	}

private:
	int m_i;
};

ostream& operator<< (ostream& os, const INT& i) {
	os << '[' << i.m_i << ']';
	return os;
}

int main() {
	INT I(5);
	cout << I++;	// [5]
	cout << ++I;	// [7]
	cout << I--;	// [7]
	cout << --I;	// [5]
	cout << *I;		// 5
}
```



注：

- 前置 ++（--），后置 ++（--）的写法
- const 的应用
- 返回值是引用还是数值，return 后面的写法不一样
- 重载的 operator<< 做友元函数



[14] 请参考《More Effective C++》条款6: Distinguish between prefix and postfix forms ofincrement and decrement operators