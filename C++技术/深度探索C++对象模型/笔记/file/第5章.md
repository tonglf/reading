## 第 5 章  构造、析构、拷贝语意学（Semantics of Construction Destruction，and Copy）

考虑下面这个 abstract base class 声明：

```cpp
class Abstract_base {
public:
	virtual ~Abstract_base() = 0;
	virtual void interface() const = 0;
    virtual const char* mumble() const { return _murmble; }
protected:
	char *_mumble;
};
```

重新定义 Abstract_base 如下，才是比较适当的一种设计：

```cpp
class Abstract_base {
public:
	virtual ~Abstract_base();	// 译注:不再是 pure virtual
	virtual void interface() = 0;	//译注:不再是const
	const char*mumble() const { return _mumble; } //译注:不再是virtual
protected;
	Abstract_base(char *pc=0);	// 新增-一个带有唯一参数的 constructor
	char *_menble;
};
```



### 5.1  “无继承” 情况下的对象构造



### 5.2  继承体系下的对象构造

constructor 执行算法通常如下：

1. 在 derived class constructor 中，“所有 virtual base classes” 及 “上一层 base class” 的 constructors 会被调用。
2. 上述完成之后，对象的 vptr(s) 被初始化，指向相关的  virtual table(s)。
3. 如果有 member initialization list 的话，将在 constructor 体内扩展开来。这必须在 vptr 被设定之后才进行，以免有一个 virtual memberfunction 被调用。
4. 最后，执行程序员所提供的码。



### 5.3  对象复制语意学（Object Copy Semantics）



### 5.4  对象的效能（Object Efficiency）



### 5.5  析构语意学（Semantics of Destruction）

当一个类不需要 destructor 时，为它提供一个 destructor 是低效率的，即使提供了 constructor 了。当一个类里包含指针成员变量，或成员对象内有指针成员变量（成员对象应该有 destructor），这些指针或许指向其他地址，那这时应该提供一个 destructor。

destructor 被扩展形式：

1. destructor 的函数本身首先被执行。
2. 如果 class 拥有 member class objects，而后者拥有 destructors，那么它们会以其声明顺序的相反顺序被调用。
3. 如果 object 内带一个 vptr，则现在被重新设定，指向适当之 base class 的 virtual table。
4. 如果有任何直接的（上一层〉nonvirtual base classes 拥有 destructor，它们会以其声明顺序的相反顺序被调用。
5. 如果有任何 virtual base classes 拥有 destructor，而当前讨论的这个 class 是最尾端（ most-derived) 的  class，那么它们会以其原来的构造顺序的相反顺序被调用。



### 本章小结

#### 1、几点类设计原则

**1.即使是一个抽象基类，如果它有非静态数据成员，也应该给它提供一个带参数的构造函数**，来初始化它的数据成员。或许你可以通过其派生类来初始化它的数据成员（假如nostatic data member为publish或protected）,但这样做的后果则是破坏了数据的封装性，使类的维护和修改更加困难。由此引申，类的data member应当被初始化，且只在其构造函数或其member function中初始化。

**2.不要将析构函数设计为纯虚的，这不是一个好的设计。**将析构函数设计为纯虚函数意味着，即使纯虚函数在语法上允许我们只声明而不定义纯虚函数，但还是必须实现该纯虚析构函数，否则它所有的继承类都将遇到链接错误。一个不能派生继承类的抽象类有什么存在的意义？必须定义纯虚析构函数，而不能仅仅声明它的原因在于：每一个继承类的析构函数会被编译器加以扩展，以静态调用方式其每一个基类的析构函数（假如有的话，不论是显示的还是编译器合成的），所以只要任何一个基类的析构函数缺乏定义，就会导致链接失败。矛盾就在这里，纯虚函数的语法，允许只声明而不定义纯虚析构函数，而编译器则死脑筋的看到一个其基类的
析构函数声明，则去调用它的实体，而不管它有没有被定义。

**3.真的必要的时候才使用虚函数，不要滥用虚函数。**虚函数意味着不
小的成本，编译很可能给你的类带来膨胀效应：

- 每一个对象要多负担一个word的vptr。
- 给每一个构造函数（不论是显示的还是编译器合成的），插入一些代码来初始化vptr，这些代码必须被放在所有基类构造函数的调用之后，但需在任意用户代码之前。没有构造函数则需要合成，并插入代码。
- 合成一个拷贝构造函数和一个复制操作符（如果没有的话），并插入对vptr的初始化代码，有的话也需要插入vptr的初始化代码。
- 意味着，如果具有bitwise语意，将不再具有，然后是变大的对象、没有那么高效的构造函数，没有那么高效的复制控制。

**4.不能决定一个虚函数是否需要 const ，那么就不要它。**

**5.决不在构造函数或析构函数中使用虚函数机制。**在构造函数中，每次调用虚函数会被决议为当前构造函数所对应类的虚函数实体，虚函数机制并不起作用。当一个base类的构造函数含有对虚函数vf()的调用，当其派生类derived的构造函数调用基类base的构造函数的时候，其中调用的虚函数vf()是base中的实体，而不是derived中的实体。这是由vptr初始化的位置决定的——在所有基类构造函数调用之后，在程序员供应的代码或是成员初始化队列之前。因构造函数的调用顺序是：有根源到末端，由内而外，所以对象的构造过程可以看成是，从构建一个最基础的对象开始，一步步构建成一个目标对象。析构函数则有着与构造相反的顺序，因此在构造或析构函数中使用虚函数机制，往往不是程序员的意图。若要在构造函数或析构函数中调用虚函数，应当直接以静态方式调用，而不要通过虚函数机制。