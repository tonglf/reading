## 第 4 章  Function 语意学（The Semantics of Function）

### 4.1  Member 的各种调用方式

C++ 成员函数的三种类型：非静态、虚拟、静态。

#### Nonstatic Member Functions（非静态成员函数）

C++ 的设计准则之一就是：nonstatic member function 至少必须和一般的 nonmember function 有相同的效率。

**nonstatic member function 在调用时，会被转化为 nonmember function 的形式**，转化步骤如下：

1. 改写函数的 signature（译注:意指函数原型）以安插一个额外的参数到 member function 中，用以提供一个存取管道，使 class object 得以调用该函数。该额外参数被称为 this 指针：

    ```cpp
    // non-const nonstatic member 之增长过程 
    Point3d
    Point3d::magnitude(Point3d *const this)
    ```

    如果 member function 是 const，则变成：

    ```cpp
    // const nonstatic member 之扩张过程
    Point3d
    Point3d::magnitude(const Point3d *const this)
    ```

2. 将每一个 “对 nonstatic data member 的存取操作” 改为经由 this 指针来存取：

    ```cpp
    return sqrt(this->_x * this->_x + this->_y * this->_y + this->_z * this->_z);
    ```

3. 将 member function 重新写成一个外部函数，对函数名称进行 “mangling” 处理，使它在程序中成为独一无二的语汇:

    ```cpp
    extern magnitude__7Point3dFv(register Point3d *const this) ;
    ```

    现在这个函数已经被转换好了，而其每一个调用操作也都必须转换．于是:

    ```cpp
    obj.magnitude();
    // 变成了:
    magnitude__7Point3dFv(&obj);
    
    ptr->magnitude();
    // 变成了:
    magnitude__7Point3dFv(ptr);
    ```

函数内部被转化为：

```cpp
// 以下描述“named return value函数”的内部转化
// 使用C++伪码
void
normalize_7Point3dFv(register const Point3d *const this,Point3d &___result)
{
	register float mag = this->magnitude();
	// default constructor
	__result.Point3d::Point3d();
    
    __result._x = this->_x/mag;
    __result._y = this->_y/mag;
    __result._z = this->_z/mag;
	return;
}
```

**名称的特殊处理**

> 成员函数被转化为非成员函数，函数该如何命名呢？

- 一般而言，member 的名称前面会被加上 class 名称，形成独一无二的命名。

- 为避免多个重载函数实体拥有相同的名称，让它们独一无二，名称中再加上它们的参数链表（可以从函数原型中参考得到)。



#### Virtual Member Functions（虚拟成员函数）

如果 normalize() 是一个 virtual member function，那么以下的调用：

```cpp
ptr->normalize();
```

将会被内部转化为：

```cpp
*ptr->vptr[1])(ptr);
```

通过虚函数表、虚函数指针进行调用。



#### Static Member Functions（静态成员函数）

Static member functions 的主要特性就是它没有 this 指针。以下的次要特性统统根源于其主要特性：

- 它不能够直接存取其 class 中的 nonstatic members；
- 它不能够被声明为 const、 volatile 或 virtual；
- 它不需要经由 class object 才被调用

Static Member Functions 也被转化为一般的 nonmember 函数调用，如下：

```cpp
obj.normalize();
ptr->normalize();
// 转化为：
normalize_7Point3dsFv();
normalize_7Point3dsFV();
```

Static member function 由于缺乏 this 指针，因此差不多等同于 nonmember function。

**注意：**

如果 class 的设计者把 static data member 声明为 nonpublic（这一直被视为是一种好的习惯），那么他就必须提供一个或多个 member functions 来存取该 member。



### 4.2  Virtual Member Function （虚拟成员函数）

在C++中，多态 ( polymorphism) 表示 “以一个 public base class 的指针（或 reference )，寻址出一个 derived class object” 的意思。

Point class 体系中：

```cpp
class Point {
public:
	virtual ~Point ( ) ;
	virtual Point& multi(float) = 0 ;
    // ...其它操作
	float x() const { return _x; }
	virtual float y() const { return 0; }
    virtual float z() const { return 0; }
    // ...
protected :
	Point(float x = 0.0 );
    float _x;
} ;

// Point2d 继承 Point 并改写了虚函数
// Point3d 继承 Point2d 并改写了虚函数
```

单一继承下，Virtual Table 的布局：

![](images/4.1.png)

现在，如果有这样的式子:

```cpp
ptr->z () ;
```

那么，如何有足够的知识在编译时期设定 virtual function 的调用呢？
一般而言，并不知道 ptr 所指对象的真正类型。然而知道，经由 ptr 可以存取到该对象的 virtual table。
虽然不知道哪一个 z() 函数实体会被调用，但我知道每一个 z() 函数地址都被放在 slot 4。这些信息使得编译器可以将该调用转化为：

```cpp
(*ptr->vpt:[4])(ptr);
```

现在不知道的就是 ptr 指向哪个实体，这将在执行期获得。



**多重继承下的 Virtual Function**

![](images/4.2.png)



**虚拟继承下的 Virtual Function**

![](images/4.3.png)



### 4.3  函数的效能

- nonmember 或 static member 或 nonstatic member 函数都被转化为完全相同的形式，所以三者的效率完全相同。

- 虚函数效率较前三者稍逊，多重继承效率次之，虚拟继承效率最低，随机继承深度的增加，效率会越来越低。



### 4.4  指向 Member Function 的指针（Pointer-to-Member Functions）

**支持 “指向 Virtual Member Functions” 的指针**

对一个 nonstatic member function 取其地址，将获得该函数在内存中的地址。然而面对一个 virtual function，其地址在编译时期是未知的，所能知道的仅是 virtual function 在其相关之 virtual table 中的索引值。也就是说，对一个 virtual member function 取其地址，所能获得的只是一个索引值。

**在多重继承之下，指向 Virtual Functions 的指针**

主要需要分辨该指针会指向哪？指向一个地址还是一个索引。

**“指向 Member Functions 之指针” 的效率**

与 4.3 节各类函数的效能一致。



### 4.5  Inline Functions

关键词 inline (或 class declaration 中的 member function 或 friend function 的定义）只是一项请求。如果这项请求被接受，编译器就必须认为它可以用一个表达式 ( expression）合理地将这个函数扩展开来。

**形式参数（Formal Arguments）**

在inline扩展期间，每一个形式参数都会被对应的实际参数取代。

如果说有什么副作用，那就是不可以只是简单地一一封塞程序中出现的每一个形式参数，因为这将导致对于实际参数的多次求值操作 (evaluations)。一般而言，面对 “会带来副作用的实际参数”，通常都需要引入临时性对象，换句话说，如果实际参数是一个常量表达式 ( constant expression ) ，我们可以在替换之前先完成其求值操作(evaluations)：后继的 inline 替换，就可以把常量直接“绑”上去。如果既不是个常量表达式，也不是个带有副作用的表达式，那么就直接代换之。

**局部变量（Local Variables）**

一般而言，inline 函数中的每一个局部变量都必须被放在函数调用的一个封闭区段中，拥有一个独一无二的名称。如果 inline 函数以单一表达式 ( expression ) 扩展多次，那么每次扩展都需要自己的一组局部变量。如果 inline 函数以分离的多个式子 (discrete statements）被扩展多次，那么只需一组局部变量，就可以重复使用。

inline 函数中的局部变量，再加上有副作用的参数，可能会导致大量临时性对象的产生。特别是如果它以单一表达式 ( expression）被扩展多次的话。



### 本章小结

本章介绍了各种情况下的 Function，熟悉各类 Function 的布局，他们是如何被调用的，以及各类 Function 的效率。