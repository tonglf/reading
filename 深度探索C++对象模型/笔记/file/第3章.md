## 第 3 章  Data 语意学（The Semantics of Data）

下面这个类大小：

```cpp
class X { };
class Y : public virtual X { };
class Z : public virtual X { };
class A : public Y, public Z { };

int main()
{
    cout << "X : " << sizeof(X) << endl;
    cout << "Y : " << sizeof(Y) << endl;
    cout << "Z : " << sizeof(Z) << endl;
    cout << "A : " << sizeof(A) << endl;

    return 0;
}
```

不同的编译器可能不同，在 Windows 和 Ubuntu 上测试，结果如下：

```cpp
X : 1
Y : 8
Z : 8
A : 16
```

解释一下：

- **X : 1**：事实上 X 并不是空的，它有一个隐晦的 1 byte 大小，那是被编译器安插进去的一个char。这使得这个class 的 objects 得以在内存中配置独一无二的地址；
- **Y : 8，Z : 8**：虚继承了 X，各有一个指针指向 X；
- **A : 16**：A 继承自 Y，Z，含有两个指针分别指向X，Y。

C++ 对象模型尽量以空间优化和存取速度优化的考虑来表现 nonstatic datamembers，并且保持和 C 语言 struct 数据配置的兼容性。它把数据直接存放在每一个 class object 之中。对于继承而来的 nonstatic data members (不管是 virtual 或 nonvirtual base class) 也是如此。不过并没有强制定义其间的排列顺序。至于 staticdata members，则被放置在程序的一个 global data segment 中，不会影响个别的 class object 的大小。在程序之中，不管该 class 被产生出多少个 objects (经由直接产生或间接派生），static data members 永远只存在一份实体（译注：甚至即使该 class 没有任何 object 实体，其 static data members 也已存在）。但是一个 template class 的 static data members 的行为稍有不同，7.1 节有详细的讨论。



### 3.1  Data Member 的绑定（The Binding of a Data Member）