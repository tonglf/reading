## 第 3 章  Data 语意学（The Semantics of Data）

下面这个类大小：

```cpp
class X { };
class Y : public virtual X { };
class Z : public virtual X { };
class A : public Y, public Z { };

int main()
{
    cout << "X : " << sizeof(X) << endl;
    cout << "Y : " << sizeof(Y) << endl;
    cout << "Z : " << sizeof(Z) << endl;
    cout << "A : " << sizeof(A) << endl;

    return 0;
}
```

不同的编译器可能不同，在 Windows 和 Ubuntu 上测试，结果如下：

```cpp
X : 1
Y : 8
Z : 8
A : 16
```

解释一下：

- **X : 1**：事实上 X 并不是空的，它有一个隐晦的 1 byte 大小，那是被编译器安插进去的一个char。这使得这个class 的 objects 得以在内存中配置独一无二的地址；
- **Y : 8，Z : 8**：虚继承了 X，各有一个指针指向 X；
- **A : 16**：A 继承自 Y，Z，含有两个指针分别指向X，Y。

C++ 对象模型尽量以空间优化和存取速度优化的考虑来表现 nonstatic datamembers，并且保持和 C 语言 struct 数据配置的兼容性。它把数据直接存放在每一个 class object 之中。对于继承而来的 nonstatic data members (不管是 virtual 或 nonvirtual base class) 也是如此。不过并没有强制定义其间的排列顺序。至于 staticdata members，则被放置在程序的一个 global data segment 中，不会影响个别的 class object 的大小。在程序之中，不管该 class 被产生出多少个 objects (经由直接产生或间接派生），static data members 永远只存在一份实体（译注：甚至即使该 class 没有任何 object 实体，其 static data members 也已存在）。但是一个 template class 的 static data members 的行为稍有不同，7.1 节有详细的讨论。



### 3.1  Data Member 的绑定（The Binding of a Data Member）

```cpp
typedef int length;

class Point3d
{
public:
	// 喔欧:length被决议（resolved）为global
	// 没问题:_va1被决议（resolved)为Point3d::_val
    void mumble(1ength val) { _val = val; )
	length mumble() { return _val; }

private:
	// length必须在“本class 对它的第一个参考操作”之前被看见
    // 这样的声明将使先前的参考操作不合法
	typedef float length;
	length _val;
};
```

在类内 mumble 中的参数类型 1ength 是使用的全局声明的 length（int），而不是类内声明的 length（float），如果要用类内声明的 1ength 需要将 1ength 定义在类前面，即在函数 mumble 前面定义，让函数 mumble 能够看到类内定义的 1ength。

上面这种重新声明的类型（typedef int length）会产生这样的效果，但平常的类型不会这样，比如内置类型 int、double 等。



### 3.2  Data Member 的布局（Data Member Layout）

Nonstatic data members 在 class object 中的排列顺序将和其被声明的顺序一样，当前各家编译器都是把一个以上的 access sections （也就是 private、public、protected 等区段）连锁在一起，依照声明的次序，成为一个连续区块。

vptr 会被放在什么位置呢？传统上它被放在所有明确声明的 members 的最后。不过如今也有一些编译器把 vptr 放在一个 class object 的最前端。



### 3.3  Data Member 的存取

**Static Data Members**

Static data members，按其字面意义，被编译器提出于 class 之外，被视为一个 global 变量（但只在 class 生命范围之内可见）。每一个 member 的存取许可（译注: private 或 protected 或 public )，以及与 class 的关联，并不会导致任何空间上或执行时间上的额外负担。

每一个 static data member 只有一个实体，存放在程序的 data segment 之中。每次程序参阅〔取用）static member，就会被内部转化为对该唯一的 extern 实体的直接参考操作。

member 其实并不在 class object 之中，因此存取 static members 并不需要通过 class object。

如果 Static data members 是一个从复杂继承关系中继承而来的 member，或者是一个 “virtual base class 的virtual base class” (或其它同等复杂的继承结构）的 member ，那无关紧要，程序之中对于 static members 还是只有唯一个实体，而其存取路径仍然是那么直接。

如果有两个 classes，每一个都声明了一个 static member freeList，那么当它们都被放在程序的 data segment时，就会导致名称冲突。编译器的解决方法是暗中对每一个 static data member 编码以获得一个独一无二的程序识别代码。



**Nonstatic Data Members**

欲对一个 nonstatic data member 进行存取操作，编译器需要把 class object 的起始地址加上 data member 的偏移量（offset )。每一个 nonstatic data member 的偏移量（ offset ）在编译时期即可获知。

虚拟继承将为 “经由 base class subobject 存取 class members ”导人一层新的间接性。

但如果 nonstatic data member 是一个 virtual base class 的 member，存取速度会比较慢一点。下面的例子：

```cpp
origin.x = 0.0;
pt->x = 0.0;
```

> “从 origin 存取” 和 “从 pt 存取” 有什么重大的差异？

答案是 “当 Point3d 是一个 derived class，而在其继承结构中有一个 virtual base class，并且被存取的 member （如本例的x）是一个从该 virtual base class 继承而来的 member 时，就会有重大的差异”。这时候我们不能够说 pt 必然指向哪一种 class type (因此我们也就不知道编译时期这个 member 真正的 offset 位置)，所以这个存取操作必须延迟至执行期，经由一个额外的间接导引，才能够解决。但如果使用 origin，就不会有这些问题，其类型无疑是 Point3d class，而即使它继承自 virtual base class，members 的 offset 位置也在编译时期就固定了。一个积极进取的编译器甚至可以静态地经由 origin 就解决掉对 x 的存取。



### 3.4  ”继承“ 与 Data Member



### 3.5  对象成员的效率（Object Member Efficiency）



### 3.6  指向 Data Member 的指针（Pointer to Data Member）