## 第 2 章  构造函数语义学

### 2.1  Default Constructor 的构造操作

> **什么情况下，编译器会自动生成默认的构造函数（Default Constructor）呢？**
>
> 以下 4 种情况，会造成 “编译器必须为未声明 constructor 的 classes 合成一个 default constructor”。

- **“带有 Default Constructor” 的 Member Class Object**

如果一个 class 没有任何 constructor，但它内含一个 member object，而后者有 default constructor ，那么这个 class 的 implicit default constructor 就是“nontrivial”，编译器需要为该 class 合成出一个default constructor。不过这个合成操作只有在 constructor 真正需要被调用时才会发生。

举个例子，在下面的程序片段中，编译器为 class Bar 合成一个 default constructor:

```cpp
class Foo {
public:    
    Foo();
    Foo(int)...
};

class Bar {
public:
    Foo foo;
    char *str;
};

void foo_bar {
    Bar bar;	// Bar::foo 必须在此处初始化
    			// Bar::foo 是一个 member object，而其 class Foo 
    			// 		拥有 default constructor，符合本小节主题
    if (str) {}	// ...
}
```

被合成的 Bar default constructor 内含必要的代码，能够调用 class Foo 的 default constructor 来处理 member object Bar: :foo，但它并不产生任何代码来初始化 Bar: : str。是的，将 Bar::foo 初始化是编译器的责任，将Bar::str 初始化则是程序员的责任。被合成的 default constructor 看起来可能像这样:

```cpp
// Bar 的 default constructor可能会被这样合成
// 为 member foo 调用 class Foo 的 default constructor
inline
Bar::Bar ()
{
	// C++ 伪码
	foo.Foo::Foo();
}
```

如果你想自己写一个默认构造函数以初始化 Bar::str，如：

```cpp
Bar::Bar() {str = 0;}
```

由于默认构造函数已经被显示的定义出来，故编译器无法再生成默认构造函数，member object 的 default constructor 将被编译器扩张在以存在的 constructor 中：

```cpp
// 扩张后的 default constructor
Bar::Bar()
{
    foo.Foo::Foo();	// 附加上的
    str = 0;
}
```

如果一个 class 包含多个 class member objects，且多个 class member objects 都要求 constructor 初始化操作，C++ 语言要求以 “member objects 在 class 中的声明顺序” 来调用各个 constructors。这一点由编译器完成，它为每一个 constructor 安插程序代码，以 “member 声明顺序” 调用每一个 member 所关联的 default constructors。这些代码将被安插在 explicit user code (str = 0) 之前。

```cpp
class A { public : A(); ...};
class B { public : B(); B(int); ...};
class C { public : C(); ...};

class D {
public:
    A a;
    B b;
    C c;
    
private:
    int number;
};

// 程序员所写的 default constructors
D:D() : B(1024)
{
    number = 2048;
}

// 被扩张为
D:D() : B(1024)
{
    // 调用其 constructors
    a.A::A();
    b.B::B(1024);
    c.C::C();
    
    // explicit user code
    number = 2048;
}
```



- **“带有 Default Constructor” 的 Base Class**

类似的道理，如果一个没有任何 constructors 的 class 派生自一个 ”带有 default constructor” 的 base class，那么这个 derived class 的 default constructor 会被视为 nontrivial，并因此需要被合成出来。它将调用上一层 base classes 的 default constructor (根据它们的声明顺序)。对一个后继派生的 class 而言，这个合成的constructor 和一个 “被显式提供的 default constructor” 没有什么差异。

如果设计者提供多个 constructors，但其中都没有 default constructor 呢? **编译器会扩张现有的每一个 constructors**，将 “用以调用所有必要之 default constructors” 的程序代码加进去。它**不会合成一个新的** default constructor，因为其他 “由 user 所提供的 constructors” 存在的缘故。如果同时亦存在着 “带有 default constructors” 的 member class objects，**那些 default constructor 也会被调用——在所有 base class constructor 都被调用之后**。（先继承、再组合、后自己，这就是构造函数的顺序）



- **“带有一个 Virtual Function” 的 Class**

另有两种情况，也需要合成出 default constructor:

1. class 声明 (或继承) 一个 virtual function。
2. class 派生自一个继承串链，其中有一个或更多的 virtual base classes。

不管哪一种情况，由于缺乏由 user 声明的 constructors，编译器会详细记录合成一个 default constructor 的必要信息。以下面这个程序片段为例:

```cpp
class Widget {
public:
    virtual void flip() = 0;
    // ...
};

void flip(const Widget& widget) { widget.flip(); }

// 假设 Bell 和 Whistle 都派生自 Widget
void foo() 
{
    Bell b;
    Whistle w;
    
    flip(b);
    flip(w);
}
```

下面两个扩张行动会在编译期间发生:

1. 一个 virtual function table (在 cfront 中被称为 vtbl) 会被编译器产生出来，内放 class 的 virtual functions 地址。
2. 每一个 class object 中，一个额外的 pointer member (也就是 vptr) 会被编译器合成出来，内含相关之 class vtbl 的地址。

**为了让这个机制发挥功效，编译器必须为每一个 Widget (或其派生类的) object 的 vptr 设定初值，放置适当的virtual table 地址。**对于 class 所定义的每一个 constructor，编译器会安插一些代码来做这样的事情 (请看5.2节）。**对于那些未声明任何 constructors 的 classes，编译器会为它们合成一个 default constructor，以便正确地初始化每一个 class object 的 vptr**。



- **“带有一个 Virtual Base Class” 的 Class**

```cpp
class x { public: int i; };
class A : public virtual x { public: int j; };
class B : public virtual x { public: double d; };
class c : public A, public B{ public: int k; };

//无法在编译时期决定（resolve）出 pa->X::i 的位置
void foo( const A* pa ) { pa->i = 1024; }

main ()
{
    foo( new A ) ;
	foo( new C ) ;
}
```

编译器无法固定住 foo() 之中 “经由 pa 而存取的 X::i” 的实际偏移位置，因为 pa 的真正类型可以改变。编译器必须改变 “执行存取操作” 的那些代码，使 X::i 可以延迟至执行期才决定下来。

对于 class 所定义的每一个 constructor，编译器会安插那些 “允许每一个 virtual base class 的执行期存取操作” 的代码。如果 class 没有声明任何 constructors，编译器必须为它合成一个 default constructor。

**总结：**

1. 不是没有定义默认构造函数编译器就会合成出来，只有以上 4 种情况才会生成默认构造函数；
2. 在合成的 default constructor 中，只有 base class subobjects 和 member class objects 会被初始化。
3. 所有其他的 nonstatic data member (如整数、整数指针、整数数组等等）都不会被初始化。



### 2.2  Copy Constructor 的构造操作

**Default Memberwise Initialization**



**Bitwise Copy Semantics （位逐次拷贝）**



**不要 Bitwise Copy Semantics**



**重新设定 Vitual Table 的指针**



**处理 Vitual Base Class Subobject**



### 2.3  程序转化语义学

**显示初始化操作（Explicit Initialization）**



**参数的初始化（Argument Initialization）**



**返回值的初始化（Return Value Initialization）**



**在使用者层面做优化（Optimization at the User Level）**



**在编译器层面做优化（Optimization at the Compiler Level）**



**Copy Constructor：要还是不要？**



### 2.4  成员们的初始化队伍

当你写下一个 constructor 时，你有机会设定 class members 的初值。要不是经由 member initialization list，就是在 constructor 函数本身之内。

下列情况中，为了让你的程序能够被顺利编译，你必须使用 member initialization list:

1. 当初始化一个 reference member 时;
2. 当初始化一个 const member 时;
3. 当调用一个 base class 的 constructor，而它拥有一组参数时;
4. 当调用一个 member class 的 constructor，而它拥有一组参数时。

在 constructor 函数本身之内初始化成员变量，效率不高：

```cpp
class Word {
	String _name;
    int _cnt;
public:
	Word() {
		_name - 0 ;
        _cnt = 0;
    }
};
```

**在这里，Word constructor 会先产生一个暂时性的 String object，然后将它初始化，再以一个 assignment 运算符将暂时性 object 指定给 _name，然后再摧毁那个暂时性 object。**以下是 constructor 可能的内部扩张结果:

```cpp
// C++伪码
Word::Word( /* this pointer goes here */ )
{
	// 调用 String 的 default constructor
	_name.String::String();
	// 产生暂时性对象
	String temp = string(0) ;
 	// "memberwise”地拷贝 _name
	_name.string::operator=( temp ) ;
	// 摧毁暂时性对象
	temp.string::~String() ;
	cnt 0;
}
```

较佳的方式：

```cpp
Word::Word() : _name(0)
{
    _cnt = 0;
}
```

**编译器会一一操作 initialization list，以适当次序在 constructor 之内安插初始化操作，并且在任何 explicit user code 之前。**例如，先前的 Word constructor 被它会被扩张成：

```cpp
Word::Word( /* this pointer goes here */ )
{
    // 调用 String( int ) constructor
    _name.String::String(0);
    _cnt = 0;
}
```

> **那么 _cnt 不用写进 member initialization list 中去吗？**
>
> 不用，因为 _cnt 为内置类型，不会造成额外的内存消耗。

**list 中的项目次序是由 class 中的 members 声明次序决定，不是由 initialization list 中的排列次序决定。**

```cpp
class X {
public:
	int i;
    int j;

	// 你看出问题了吗
    X ( int val ) : j( val ), i( j )	// 有陷阱的写法
    { }
};

class Y {
public:
	int i;
    int j;

	Y ( int val ): j( val )	// 修改后的写法
	{ i = j; }	
};

// 测试
int main ()
{
	X x (3);
    Y y (5);
    
	printf ( "x.i = %d x.j = %d \n", x.i, x.j );	// x.i = -2124198216  x.j = 3
    printf ( "y.i = %d y.j = %d \n", y.i, y.j );	// y.i = 5  y.j = 5
    
	return 0;
}
```

**上述说明，编译器会对 initialization list 一一处理并可能重新排序，以反映出 members 的声明次序，它会安插一些代码到 constructor 体内，并置于任何 explicituser code 之前。**

**总结：**

1. 成员变量初始化位置在初始化列表要比函数体内，效率更高，后者会产生临时变量；
2. 不是所有的类型使用初始化列表进行初始化效率都会提升，内置类型就不会；
3. 初始化列表在在初始化过程中要看成员变量在类内定义的顺序，而不是初始化列表中的顺序，故尽量保持定义顺序与列表初始化顺序一致；
4. 当初始化列表与函数体内都有代码要执行时，先执行初始化列表，后执行函数体内代码。