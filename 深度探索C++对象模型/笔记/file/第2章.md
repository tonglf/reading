## 第 2 章  构造函数语义学

### 2.1  Default Constructor 的构造操作

> **什么情况下，编译器会自动生成默认的构造函数（Default Constructor）呢？**
>
> 以下 4 种情况，会造成 “编译器必须为未声明 constructor 的 classes 合成一个 default constructor”。

#### “带有 Default Constructor” 的 Member Class Object

如果一个 class 没有任何 constructor，但它内含一个 member object，而后者有 default constructor ，那么这个 class 的 implicit default constructor 就是“nontrivial”，编译器需要为该 class 合成出一个default constructor。不过这个合成操作只有在 constructor 真正需要被调用时才会发生。

举个例子，在下面的程序片段中，编译器为 class Bar 合成一个 default constructor:

```cpp
class Foo {
public:    
    Foo();
    Foo(int)...
};

class Bar {
public:
    Foo foo;
    char *str;
};

void foo_bar {
    Bar bar;	// Bar::foo 必须在此处初始化
    			// Bar::foo 是一个 member object，而其 class Foo 
    			// 		拥有 default constructor，符合本小节主题
    if (str) {}	// ...
}
```

被合成的 Bar default constructor 内含必要的代码，能够调用 class Foo 的 default constructor 来处理 member object Bar: :foo，但它并不产生任何代码来初始化 Bar: : str。是的，将 Bar::foo 初始化是编译器的责任，将Bar::str 初始化则是程序员的责任。被合成的 default constructor 看起来可能像这样:

```cpp
// Bar 的 default constructor可能会被这样合成
// 为 member foo 调用 class Foo 的 default constructor
inline
Bar::Bar ()
{
	// C++ 伪码
	foo.Foo::Foo();
}
```

如果你想自己写一个默认构造函数以初始化 Bar::str，如：

```cpp
Bar::Bar() {str = 0;}
```

由于默认构造函数已经被显示的定义出来，故编译器无法再生成默认构造函数，member object 的 default constructor 将被编译器扩张在以存在的 constructor 中：

```cpp
// 扩张后的 default constructor
Bar::Bar()
{
    foo.Foo::Foo();	// 附加上的
    str = 0;
}
```

如果一个 class 包含多个 class member objects，且多个 class member objects 都要求 constructor 初始化操作，C++ 语言要求以 “member objects 在 class 中的声明顺序” 来调用各个 constructors。这一点由编译器完成，它为每一个 constructor 安插程序代码，以 “member 声明顺序” 调用每一个 member 所关联的 default constructors。这些代码将被安插在 explicit user code (str = 0) 之前。

```cpp
class A { public : A(); ...};
class B { public : B(); B(int); ...};
class C { public : C(); ...};

class D {
public:
    A a;
    B b;
    C c;
    
private:
    int number;
};

// 程序员所写的 default constructors
D:D() : B(1024)
{
    number = 2048;
}

// 被扩张为
D:D() : B(1024)
{
    // 调用其 constructors
    a.A::A();
    b.B::B(1024);
    c.C::C();
    
    // explicit user code
    number = 2048;
}
```



#### “带有 Default Constructor” 的 Base Class

类似的道理，如果一个没有任何 constructors 的 class 派生自一个 ”带有 default constructor” 的 base class，那么这个 derived class 的 default constructor 会被视为 nontrivial，并因此需要被合成出来。它将调用上一层 base classes 的 default constructor (根据它们的声明顺序)。对一个后继派生的 class 而言，这个合成的constructor 和一个 “被显式提供的 default constructor” 没有什么差异。

如果设计者提供多个 constructors，但其中都没有 default constructor 呢? **编译器会扩张现有的每一个 constructors**，将 “用以调用所有必要之 default constructors” 的程序代码加进去。它**不会合成一个新的** default constructor，因为其他 “由 user 所提供的 constructors” 存在的缘故。如果同时亦存在着 “带有 default constructors” 的 member class objects，**那些 default constructor 也会被调用——在所有 base class constructor 都被调用之后**。（先继承、再组合、后自己，这就是构造函数的顺序）



#### “带有一个 Virtual Function” 的 Class

另有两种情况，也需要合成出 default constructor:

1. class 声明 (或继承) 一个 virtual function。
2. class 派生自一个继承串链，其中有一个或更多的 virtual base classes。

不管哪一种情况，由于缺乏由 user 声明的 constructors，编译器会详细记录合成一个 default constructor 的必要信息。以下面这个程序片段为例:

```cpp
class Widget {
public:
    virtual void flip() = 0;
    // ...
};

void flip(const Widget& widget) { widget.flip(); }

// 假设 Bell 和 Whistle 都派生自 Widget
void foo() 
{
    Bell b;
    Whistle w;
    
    flip(b);
    flip(w);
}
```

下面两个扩张行动会在编译期间发生:

1. 一个 virtual function table (在 cfront 中被称为 vtbl) 会被编译器产生出来，内放 class 的 virtual functions 地址。
2. 每一个 class object 中，一个额外的 pointer member (也就是 vptr) 会被编译器合成出来，内含相关之 class vtbl 的地址。

**为了让这个机制发挥功效，编译器必须为每一个 Widget (或其派生类的) object 的 vptr 设定初值，放置适当的virtual table 地址。**对于 class 所定义的每一个 constructor，编译器会安插一些代码来做这样的事情 (请看5.2节）。**对于那些未声明任何 constructors 的 classes，编译器会为它们合成一个 default constructor，以便正确地初始化每一个 class object 的 vptr**。



#### “带有一个 Virtual Base Class” 的 Class

```cpp
class x { public: int i; };
class A : public virtual x { public: int j; };
class B : public virtual x { public: double d; };
class c : public A, public B{ public: int k; };

//无法在编译时期决定（resolve）出 pa->X::i 的位置
void foo( const A* pa ) { pa->i = 1024; }

main ()
{
    foo( new A ) ;
	foo( new C ) ;
}
```

编译器无法固定住 foo() 之中 “经由 pa 而存取的 X::i” 的实际偏移位置，因为 pa 的真正类型可以改变。编译器必须改变 “执行存取操作” 的那些代码，使 X::i 可以延迟至执行期才决定下来。

对于 class 所定义的每一个 constructor，编译器会安插那些 “允许每一个 virtual base class 的执行期存取操作” 的代码。如果 class 没有声明任何 constructors，编译器必须为它合成一个 default constructor。



#### 总结

1. 不是没有定义默认构造函数编译器就会合成出来，只有以上 4 种情况才会生成默认构造函数；
2. 在合成的 default constructor 中，只有 base class subobjects 和 member class objects 会被初始化。
3. 所有其他的 nonstatic data member (如整数、整数指针、整数数组等等）都不会被初始化。



### 2.2  Copy Constructor 的构造操作

发生拷贝的三种情况：

```cpp
class X { ... };
X x;

// 1
X xx = x;

// 2
void bar ()
{
    X xx;
    foo(xx);
    // ...
}

// 3
X foo_bar ()
{
    X xx;
    // ...
    return xx;
}
```



#### Default Memberwise Initialization

**如果 class 没有提供一个 explicit copy constructor 又当如何？当 class object 以 “相同 class 的另一个 object” 作为初值时，其内部是以所谓的 default memberwise initialization 手法完成的**，也就是把每一个内建的或派生的data member (例如一个指针或一数组) 的值，从某个 object 拷贝一份到另一个 object 身上。不过它并不会拷贝其中的 member class object，而是以递归的方式施行 memberwise initializalion。例如，考虑下面这个 class 声明：

```cpp
class String {
public:
	// ..．没有explicit copy constructorprivate:
	char *str;
    int len;
};

class Word {
public:
	// ... 没有explicit copy constructor
private :
	int occurs;
	String _word; // 译注: String object 成为class word 的一个member!
};
```

**Word 类发生拷贝时：** Word object 的 default memberwise initialization 会拷贝其内建的 member _occurs，然后再于 String member object _word 身上递归实施 memberwis einitialization。



#### Bitwise Copy Semantics （位逐次拷贝）

**决定一个 copy constructor 是否被合成的标准在于 class 是否展现出所谓的 “bitwise copy semantics”。**

存在以下拷贝：

```cpp
Word noun("book");

Word verb = noun;
```

class Word 的一种定义：

```cpp
// 以下声明展现了 bitwise copy semantics
class Word {
public:
    Word(const char*);
    ~Word() { delete[] str; }
	// ...
private :
	int cnt;
	char* str;
};
```

这种情况下并不需要合成出一个 default copy constructor，因为上述声明展现 “default copy semantics”, 而 verb 的初始化操作也就不需要以一个函数调用收场。然而，如果 class Word 是这样声明:

```cpp
// 以下声明并未展现出 bitwise copy semantics
class word {
public:
	word (const String&);
    ~word ();
    // ...
private:
	int cnt;
    String str;
};

// 其中 String 声明了一个 explicit copy constructor:
class string {
public:
	string( const char *) ;
	~String ( ) ;
    // ...
};
```

在这个情况下，编译器必须合成出一个 copy constructor 以便调用 menberclass String object 的 copy constructor：

```cpp
// 一个被合成出来的 copy constructor
// C++ 伪码
inline Word::Word(const word& wd)
{
	str.String::string(wd.str);
    cnt = wd.cnt;    
}
```


有一点很值得注意：在这被合成出来的 copy constructor 中，如整数、指针、数组等等的 nonclass members 也都会被复制，正如我们所期待的一样。



#### 不要 Bitwise Copy Semantics

什么时候一个 class 不展现出 “bitwise copy semantics” 呢？有四种情况：

1. 当 class 内含一个 member object 而后者的 class 声明有一个 copy constructor 时（不论是被 class 设计者明确地声明，就像前面的 String 那样：或是被编译器合成，像 class Word 那样）。
2. 当 class 继承自一个 base class 而后者存在有一个 copy constructor 时 (再次强调，不论是被明确声明或是被合成而得）。
3. 当 class 声明了一个或多个 virtual functions 时。
4. 当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时。

前两种情况中，编译器必须将 member 或 base class 的 “copy constructors 调用操作 ”安插到被合成的 copy constructor 中。前一节 class Word 的 “合成而得的 copy constructor” 正足以说明情况 1。情况 3 和 4 有点复杂。



#### 重新设定 Vitual Table 的指针

回忆编译期间的两个程序扩张操作（只要有一个 class 声明了一个或多个 virtual functions 就会如此）:

- 增加一个 virlual function table ( vtbl )，内含每一个有作用的 virtual function 的地址。
- 将一个指向 virtual function table的指针（ vptr )，安插在每一个 class object 内。

很显然，如果编译器对于每一个新产生的 class object 的 vptr 不能成功而正确地设好其初值，将导致可怕的后果。因此，当编译器导入一个 vptr 到 class 之中时，该 class 就不再展现 bitwise semantics了。现在，编译器需要合成出一个copy constructor，以求将 vptr 适当地初始化，下面是个例子。

```cpp
class ZooAnimal {
public:
	ZooAnimal();
	virtual ~ZooAnimal();
	virtual void animate();
    virtual void draw();
    // ...
private:
	// ZooAnimal 的 animate() 和 draw() 所需要的数据
};

class Bear : public zooAnimal {
public:
	Bear();
	void animate(); // 译注:虽未明写virtua1，它其实是virtual
	void draw();	// 译注:虽未明写virtua1,它其实是virtual
	virtual void dance();
	// ...
private:
	// Bear 的 animate() 和 draw() 所需要的数据    
};
```

ZooAnimal class object 以另一个 ZooAnimal class object 作为初值，或 Bear class object 以另一个 Bear class object 作为初值，都可以直接靠 “bitwise copy semantics”完成（除了可能会有的pointer member 之外）。举个例子:

```cpp
Bear yogi ;
Bear winnie = yogi;
```


yogi 会被 default Bear constructor 初始化。而在 constructor 中， yogi 的 vptr 被设定指向Bear class 的 virtual table (靠编译器安插的码完成)。因此，把 yogi 的 vptr 值拷贝给 winnie 的 vptr 是安全的。

当一个 base class object 以其 derived class 的 object 内容做初始化操作时，其 vptr 复制操作也必须保证安全，例如:

```cpp
ZooAnimal franny = yogi; // 译注:这会发生切割 (sliced）行为
```

franny 的 vptr 不可以被设定指向 Bear class 的 virtual table (但如果 yogi 的 vptr 被直接 “bitwise copy”的话，就会导致此结果），否则当下面程序片段中的 draw() 被调用而 franny 被传进去时，就会“炸毁”( blow up）:

```cpp
void draw ( const ZooAnimal& zoey ) { zoey.draw (); }

void foo() {
	// franny 的 vptr 指向 ZooAnimal 的 virtual table,
    // 而非 Bear 的virtual table （彼由 yogi 的 vptr 指出)
    zooAnimal franny = yogi;
	draw( yogi );	// 调用 Bear::draw()
	draw( franny ); // 调用 ZooAnimal::draw()
}
```

如果 franny 被步明为一个 reference (或如果它是一个指针，而其值为 yogi 的地址），那么经由 franny 所调用的 draw() 才会是 Bear 的函数实体。

也就是说，合成出来的 ZooAnimal copy constructor 会明确设定 object 的 vptr 指向 ZooAnimal class 的 virtual table，而不是直接从右手边的 class object 中将其 vptr 现值拷贝过来。



#### 处理 Vitual Base Class Subobject

Virtual base class 的存在需要特别处理。一个 class object 如果以另一个 object 作为初值，而后者有一个 virtual base class subobject，那么也会使 “bitwisecopy semantics” 失效。



#### 总结

- Default constructors 和 copy constructors 在必要的时候才由编译器产生出来；
- 上面的 4 中情况，编译器会合成一个 copy constructor。



### 2.3  程序转化语义学

#### 显示初始化操作（Explicit Initialization）

已知有这样的定义:

```cpp
X x0;
```

下面有三个定义，每一个都明显地以 x0 来初始化其 class object：

```cpp
void foo_bar() 
{
	x1(x0);			// 译注:定义了 x1
	x x2 = x0;		// 译注:定义了x2
 	X x3 = (x0);	// 译注:定义了x3
}
```

必要的程序转化有两个阶段:

1. 重写每一个定义，其中的初始化操作会被剥除。（译注:这里所谓的 “定义” 是指上述的 x1，x2，x3 三行；在严谨的 C++ 用词中，“定义” 是指 “占用内存” 的行为)

2. class 的 copy constructor 调用操作会被安插进去。

举个例子，在明确的双阶段转化之后，foo_bar() 可能看起来像这样:

```cpp
// 可能的程序转换
// C++伪码
void foo_bar() 
{
	X x1;	// 译注:定义被重写，初始化操作被剥除
    X x2;	// 译注:定义被重写，初始化操作被剥除 
    X x3;	// 译注:定义被重写，初始化操作被剥除

    // 编译器安插 X copy construction 的调用操作 
    x1.X::X( x0 );
	x2.X::X( x0 );
    x3.X::X( xo );
}
```



#### 参数的初始化（Argument Initialization）

```cpp
// 函数声明
void foo(X x0);

// 调用
X xx;
foo(xx);
```

编译器可能将上述代码转换如下：

```cpp
// C++伪码
// 编译器产生出来的暂时对象
X __temp0;

// 编译器对 copy constructor 的调用
__temp0.X::X( xx );

// 重新改写函数调用操作，以便使用上述的暂时对象
foo(__temp0);

// foo 函数结束后，将临时变量 __temp0 销毁
```



#### 返回值的初始化（Return Value Initialization）

已知下面这个函数定义:

```cpp
X bar()
{
	X xx;
	// 处理x ...
    return xx;
}
```

你可能会问 bar() 的返回值如何从局部对象 xx 中拷贝过来？Stroustrup 在cfrto中的解决方法是一个双阶段转化:

1. 首先加上一个额外参数，类型是 class object 的一个 reference。这个参数将用来放置被 “拷贝建构( copy constructed)” 而得的返回值。
2. 在 return 指令之前安插一个 copy constructor 调用操作，以便将欲传回之 object 的内容当做上述新增参数的初值。

真正的返回值是什么？最后一个转化操作会重新改写函数，使它不传回任何值。根据这样的算法，bar() 转换如下:

```cpp
// 函数转换
// 以反映出 copy constructor 的应用
// C++伪码
void bar( X&__result )	// 译注:加上一个额外参数
{
	X xx;
	// 编译器所产生的 default constructor 调用操作
    xx.X::X();
    
    // ...处理×x
    
    // 编译器所产生的 copy constructor 调用操作
    result.x::XX(xx);
    
	return ;
}
```

现在编译器必须转换每一个 bar() 调用操作，以反映其新定义。例如:

```cpp
X xx = bar();
```

将被转换为下列两个指令句:

```cpp
// 注意，不必施行 default constructor
X xx;
bar(xx);
```

而：

```cpp
bar().memfunc(); // 译注:执行bar() 所传回之 X class object 的 memfunc ( )
```

可能被转化为:

```cpp
// 编译器所产生的暂时对象 __temp0;
(bar(__temp0), __temp0).memfunc();
```

同样道理，如果程序声明了一个函数指针，像这样:

```cpp
X (*pf)() ;
pf = bar;
```

它也必须被转化为:

```cpp
void (*pf)(X&);
pf = bar;
```



#### 在使用者层面做优化（Optimization at the User Level）

```cpp
X bar( const T &y, const T&z )
{
	X xx;
	// 以 y 和 z 来处理 xx
    return xx;
}
```

那会要求 x 被 “memberwise” 地拷贝到编译器所产生的 _result 之中。Jonathan 定义另一个 constructor，可以直接计算 xx 的值：

```cpp
void bar( const T &y, const T&z )
{
	return X( y, z );
}
```

于是当bar() 的定义被转换之后，效率会比较高:

```cpp
// C++伪码
void bar( X& __result ) // 译注:是否应为 bar( X& _result, const T& y, const T& z)
{
	result.X::X(y, z);
	return;
}
```

__result 被直接计算出来，而不是经由 copy constructor 拷贝而得！不过这种解决方法受到了某种批评，怕那些特殊计算用途的 constructor 可能会大量扩散。在这个层面上，class 的设计是以效率考虑居多，而不是以 “支持抽象化” 为优先。



**在编译器层面做优化（Optimization at the Compiler Level）**

在一个如 bar() 这样的函数中，所有的 return 指令传回相同的具名数值（译注: named value)，因此编译器有可能自己做优化，方法是以 result 参数取代 namedl return value（NRV）。例如下面的 bar() 定义;

```cpp
X bar()
{
	X xx;
	// ... 处理 xx
    return xx;
}
```

编译器把其中的 xx 以 \_\_result 取代:

```cpp
void bar(X &__result)
{
	// default constructor被调用
    // C++伪码
	__result.X::X();
    
    // ...直接处理 __result
	return;
}
```



#### Copy Constructor：要还是不要？



#### 总结

本小节主要讲述了在实际代码中哪些情况会调用 copy constructor（三种情况，显示初始化、参数值、返回值），并据此进行优化，同时根据 copy constructor 的应用场景判断是否有必要在类中显示实现 copy constructor。



### 2.4  成员们的初始化队伍

当你写下一个 constructor 时，你有机会设定 class members 的初值。要不是经由 member initialization list，就是在 constructor 函数本身之内。

下列情况中，为了让你的程序能够被顺利编译，你必须使用 member initialization list:

1. 当初始化一个 reference member 时;
2. 当初始化一个 const member 时;
3. 当调用一个 base class 的 constructor，而它拥有一组参数时;
4. 当调用一个 member class 的 constructor，而它拥有一组参数时。

在 constructor 函数本身之内初始化成员变量，效率不高：

```cpp
class Word {
	String _name;
    int _cnt;
public:
	Word() {
		_name - 0 ;
        _cnt = 0;
    }
};
```

**在这里，Word constructor 会先产生一个暂时性的 String object，然后将它初始化，再以一个 assignment 运算符将暂时性 object 指定给 _name，然后再摧毁那个暂时性 object。**以下是 constructor 可能的内部扩张结果:

```cpp
// C++伪码
Word::Word( /* this pointer goes here */ )
{
	// 调用 String 的 default constructor
	_name.String::String();
	// 产生暂时性对象
	String temp = string(0) ;
 	// "memberwise”地拷贝 _name
	_name.string::operator=( temp ) ;
	// 摧毁暂时性对象
	temp.string::~String() ;
	cnt 0;
}
```

较佳的方式：

```cpp
Word::Word() : _name(0)
{
    _cnt = 0;
}
```

**编译器会一一操作 initialization list，以适当次序在 constructor 之内安插初始化操作，并且在任何 explicit user code 之前。**例如，先前的 Word constructor 被它会被扩张成：

```cpp
Word::Word( /* this pointer goes here */ )
{
    // 调用 String( int ) constructor
    _name.String::String(0);
    _cnt = 0;
}
```

> **那么 _cnt 不用写进 member initialization list 中去吗？**
>
> 不用，因为 _cnt 为内置类型，不会造成额外的内存消耗。

**list 中的项目次序是由 class 中的 members 声明次序决定，不是由 initialization list 中的排列次序决定。**

```cpp
class X {
public:
	int i;
    int j;

	// 你看出问题了吗
    X ( int val ) : j( val ), i( j )	// 有陷阱的写法
    { }
};

class Y {
public:
	int i;
    int j;

	Y ( int val ): j( val )	// 修改后的写法
	{ i = j; }	
};

// 测试
int main ()
{
	X x (3);
    Y y (5);
    
	printf ( "x.i = %d x.j = %d \n", x.i, x.j );	// x.i = -2124198216  x.j = 3
    printf ( "y.i = %d y.j = %d \n", y.i, y.j );	// y.i = 5  y.j = 5
    
	return 0;
}
```

**上述说明，编译器会对 initialization list 一一处理并可能重新排序，以反映出 members 的声明次序，它会安插一些代码到 constructor 体内，并置于任何 explicituser code 之前。**



#### 总结

1. 成员变量初始化位置在初始化列表要比函数体内，效率更高，后者会产生临时变量；
2. 不是所有的类型使用初始化列表进行初始化效率都会提升，内置类型就不会；
3. 初始化列表在在初始化过程中要看成员变量在类内定义的顺序，而不是初始化列表中的顺序，故尽量保持定义顺序与列表初始化顺序一致；
4. 当初始化列表与函数体内都有代码要执行时，先执行初始化列表，后执行函数体内代码。



### 本章小结

主要三个内容：默认构造、拷贝构造、成员初始化。